
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/astrostl/slack-buddy-ai/cmd/channels.go (71.5%)</option>
				
				<option value="file1">github.com/astrostl/slack-buddy-ai/cmd/health.go (33.6%)</option>
				
				<option value="file2">github.com/astrostl/slack-buddy-ai/cmd/root.go (82.1%)</option>
				
				<option value="file3">github.com/astrostl/slack-buddy-ai/cmd/version.go (100.0%)</option>
				
				<option value="file4">github.com/astrostl/slack-buddy-ai/main.go (0.0%)</option>
				
				<option value="file5">github.com/astrostl/slack-buddy-ai/pkg/logger/logger.go (75.0%)</option>
				
				<option value="file6">github.com/astrostl/slack-buddy-ai/pkg/slack/client.go (68.5%)</option>
				
				<option value="file7">github.com/astrostl/slack-buddy-ai/pkg/slack/interface.go (100.0%)</option>
				
				<option value="file8">github.com/astrostl/slack-buddy-ai/pkg/slack/mock.go (71.4%)</option>
				
				<option value="file9">github.com/astrostl/slack-buddy-ai/pkg/slack/security.go (89.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/astrostl/slack-buddy-ai/pkg/logger"
        "github.com/astrostl/slack-buddy-ai/pkg/slack"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var channelsCmd = &amp;cobra.Command{
        Use:          "channels",
        Short:        "Manage channels in your Slack workspace",
        Long:         `Commands for managing and monitoring channels in your Slack workspace.`,
        SilenceUsage: true, // Don't show usage on errors
}

var detectCmd = &amp;cobra.Command{
        Use:   "detect",
        Short: "Detect new channels created in a time period",
        Long: `Detect new channels created during a specified time period and announce them to another channel.

The --announce-to flag is required to specify the target channel.
Use --commit to actually post messages (default is dry run mode).`,
        SilenceUsage: true, // Don't show usage on errors
        RunE:         runDetect,
}

var archiveCmd = &amp;cobra.Command{
        Use:   "archive",
        Short: "Manage inactive channel archival with warnings",
        Long: `Detect inactive channels, warn them about upcoming archival, and archive channels that remain inactive after the grace period.

This command operates in a stateless manner by using channel message history to determine activity and warning status.
Warning messages are used as state markers to track the grace period.

The bot will automatically join public channels to send warning messages. Required OAuth scopes:
- channels:read (to list channels) - REQUIRED
- channels:join (to join public channels) - REQUIRED  
- chat:write (to post warnings) - REQUIRED
- channels:manage (to archive channels) - REQUIRED

Use --commit to actually warn and archive channels (default is dry run mode).

NOTE: Currently using SECONDS for testing (will be changed back to days later).`,
        SilenceUsage: true, // Don't show usage on errors
        RunE:         runArchive,
}

var (
        since           string
        announceTo      string
        commit          bool
        warnSeconds     int
        archiveSeconds  int
        excludeChannels string
        excludePrefixes string
)

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(channelsCmd)
        channelsCmd.AddCommand(detectCmd)
        channelsCmd.AddCommand(archiveCmd)

        detectCmd.Flags().StringVar(&amp;since, "since", "8", "Number of days to look back (e.g., 1, 7, 30)")
        detectCmd.Flags().StringVar(&amp;announceTo, "announce-to", "", "Channel to announce new channels to (e.g., #general) [REQUIRED]")
        detectCmd.Flags().BoolVar(&amp;commit, "commit", false, "Actually post messages (default is dry run mode)")

        archiveCmd.Flags().IntVar(&amp;warnSeconds, "warn-seconds", 300, "Number of seconds of inactivity before warning (default: 300 = 5 minutes)")
        archiveCmd.Flags().IntVar(&amp;archiveSeconds, "archive-seconds", 60, "Number of seconds after warning (with no new activity) before archiving (default: 60 = 1 minute)")
        archiveCmd.Flags().BoolVar(&amp;commit, "commit", false, "Actually warn and archive channels (default is dry run mode)")
        archiveCmd.Flags().StringVar(&amp;excludeChannels, "exclude-channels", "", "Comma-separated list of channel names to exclude (with or without # prefix, e.g., 'general,random,#important')")
        archiveCmd.Flags().StringVar(&amp;excludePrefixes, "exclude-prefixes", "", "Comma-separated list of channel prefixes to exclude (with or without # prefix, e.g., 'prod-,#temp-,admin')")
}</span>

func runDetect(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        token := viper.GetString("token")
        if token == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("slack token is required. Set SLACK_TOKEN environment variable or use --token flag")
        }</span>

        // announce-to is mandatory
        <span class="cov8" title="1">if announceTo == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--announce-to is required")
        }</span>

        <span class="cov8" title="1">days, err := strconv.ParseFloat(since, 64)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid days format '%s': must be a number (e.g., 1, 7, 30)", since)
        }</span>

        <span class="cov8" title="1">if days &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("days must be positive, got %g", days)
        }</span>

        <span class="cov8" title="1">duration := time.Duration(days*24) * time.Hour
        cutoffTime := time.Now().Add(-duration)

        client, err := slack.NewClient(token)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create Slack client: %w", err)
        }</span>

        // Validate that the announce-to channel exists
        <span class="cov0" title="0">_, err = client.ResolveChannelNameToID(announceTo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("announce-to channel '%s' not found: %w", announceTo, err)
        }</span>

        <span class="cov0" title="0">return runDetectWithClient(client, cutoffTime, announceTo, !commit)</span>
}

func runDetectWithClient(client *slack.Client, cutoffTime time.Time, announceChannel string, isDryRun bool) error <span class="cov8" title="1">{
        newChannels, allChannels, err := client.GetNewChannelsWithAllChannels(cutoffTime)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get new channels: %w", err)
        }</span>

        <span class="cov8" title="1">if len(newChannels) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Show simple summary list on one line
        <span class="cov8" title="1">channelList := make([]string, len(newChannels))
        for i, channel := range newChannels </span><span class="cov8" title="1">{
                channelList[i] = "#" + channel.Name
        }</span>
        <span class="cov8" title="1">fmt.Printf("New channels found (%d): %s\n\n", len(newChannels), strings.Join(channelList, ", "))

        if announceChannel != "" </span><span class="cov8" title="1">{
                message := client.FormatNewChannelAnnouncement(newChannels, cutoffTime)

                // Extract channel names for duplicate checking
                channelNames := make([]string, len(newChannels))
                for i, channel := range newChannels </span><span class="cov8" title="1">{
                        channelNames[i] = channel.Name
                }</span>

                // Check for duplicate announcements and track skipped channels (regardless of dry run mode)
                <span class="cov8" title="1">fmt.Printf("Checking for duplicate announcements in %s...\n\n", announceChannel)
                isDuplicate, skippedChannels, err := client.CheckForDuplicateAnnouncementWithDetailsAndChannels(announceChannel, message, channelNames, cutoffTime, allChannels)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithFields(logger.LogFields{
                                "channel": announceChannel,
                                "error":   err.Error(),
                        }).Warn("Failed to check for duplicate announcements, proceeding with post")
                }</span>

                <span class="cov8" title="1">var finalMessage string
                var channelsToAnnounce []slack.Channel

                if isDuplicate </span><span class="cov8" title="1">{
                        // Separate channels into new and skipped
                        var newChannelsToAnnounce []string
                        for _, channelName := range channelNames </span><span class="cov8" title="1">{
                                skipped := false
                                for _, skippedChannel := range skippedChannels </span><span class="cov8" title="1">{
                                        if channelName == skippedChannel </span><span class="cov8" title="1">{
                                                skipped = true
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if !skipped </span><span class="cov0" title="0">{
                                        newChannelsToAnnounce = append(newChannelsToAnnounce, channelName)
                                }</span>
                        }

                        <span class="cov8" title="1">if len(skippedChannels) &gt; 0 </span><span class="cov8" title="1">{
                                fmt.Printf("Channels already announced (skipped): %s\n", strings.Join(skippedChannels, ", "))
                        }</span>

                        // If all channels were already announced, skip entirely
                        <span class="cov8" title="1">if len(newChannelsToAnnounce) == 0 </span><span class="cov8" title="1">{
                                fmt.Printf("All channels already announced, skipping announcement to %s\n", announceChannel)
                                return nil
                        }</span>

                        // Update the message to only include new channels
                        <span class="cov0" title="0">var newChannelsToFormat []slack.Channel
                        for _, channel := range newChannels </span><span class="cov0" title="0">{
                                for _, newChannelName := range newChannelsToAnnounce </span><span class="cov0" title="0">{
                                        if channel.Name == newChannelName </span><span class="cov0" title="0">{
                                                newChannelsToFormat = append(newChannelsToFormat, channel)
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">channelsToAnnounce = newChannelsToFormat
                        finalMessage = client.FormatNewChannelAnnouncement(newChannelsToFormat, cutoffTime)
                        
                        // Show what's being announced
                        if len(newChannelsToAnnounce) &gt; 0 </span><span class="cov0" title="0">{
                                var announcingList []string
                                for _, channelName := range newChannelsToAnnounce </span><span class="cov0" title="0">{
                                        announcingList = append(announcingList, "#"+channelName)
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("Announcing channels: %s (skipped %d already announced)\n", strings.Join(announcingList, ", "), len(skippedChannels))</span>
                        }
                } else<span class="cov8" title="1"> {
                        channelsToAnnounce = newChannels
                        finalMessage = message
                }</span>

                <span class="cov8" title="1">if isDryRun </span><span class="cov8" title="1">{
                        // For dry run, create a pretty version with readable names
                        dryRunMessage := client.FormatNewChannelAnnouncementDryRun(channelsToAnnounce, cutoffTime)
                        
                        fmt.Printf("\n--- DRY RUN ---\n")
                        fmt.Printf("Would announce to channel: %s\n", announceChannel)
                        fmt.Printf("Message content:\n%s\n", dryRunMessage)
                        fmt.Printf("--- END DRY RUN ---\n")
                        fmt.Printf("\nTo actually post this announcement, add --commit to your command\n")
                }</span> else<span class="cov8" title="1"> {
                        if err := client.PostMessage(announceChannel, finalMessage); err != nil </span><span class="cov8" title="1">{
                                logger.WithFields(logger.LogFields{
                                        "channel": announceChannel,
                                        "error":   err.Error(),
                                }).Error("Failed to post announcement")
                                return fmt.Errorf("failed to post announcement to %s: %w", announceChannel, err)
                        }</span>
                        <span class="cov8" title="1">fmt.Printf("Announcement posted to %s\n", announceChannel)</span>
                }
        } else<span class="cov8" title="1"> if isDryRun </span><span class="cov8" title="1">{
                // Show what announcement message would look like even without a target channel
                message := client.FormatNewChannelAnnouncement(newChannels, cutoffTime)
                fmt.Printf("\n--- DRY RUN ---\n")
                fmt.Printf("Announcement message dry run (use --announce-to to specify target):\n%s\n", message)
                fmt.Printf("--- END DRY RUN ---\n")
                fmt.Printf("\nTo actually post announcements, add --commit to your command\n")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func runArchive(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        token := viper.GetString("token")
        if token == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("slack token is required. Set SLACK_TOKEN environment variable or use --token flag")
        }</span>

        <span class="cov8" title="1">if warnSeconds &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("warn-seconds must be positive, got %d", warnSeconds)
        }</span>

        <span class="cov8" title="1">if archiveSeconds &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("archive-seconds must be positive, got %d", archiveSeconds)
        }</span>

        <span class="cov0" title="0">client, err := slack.NewClient(token)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Slack client: %w", err)
        }</span>

        <span class="cov0" title="0">return runArchiveWithClient(client, warnSeconds, archiveSeconds, !commit, excludeChannels, excludePrefixes)</span>
}

func runArchiveWithClient(client *slack.Client, warnSeconds, archiveSeconds int, isDryRun bool, excludeChannels, excludePrefixes string) error <span class="cov8" title="1">{
        logger.WithFields(logger.LogFields{
                "warn_seconds":    warnSeconds,
                "archive_seconds": archiveSeconds,
                "dry_run_mode":    isDryRun,
        }).Info("Starting inactive channel analysis")

        fmt.Printf("🔍 Analyzing inactive channels...\n\n")

        // Get user map for name resolution
        fmt.Printf("📞 API Call 1: Getting user list for name resolution...\n")
        userMap, err := client.GetUserMap()
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "rate_limited") || strings.Contains(err.Error(), "rate limit") </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️  Slack API rate limit exceeded on user list.\n")
                        fmt.Printf("   The system should have done backoff.\n")
                        return fmt.Errorf("rate limited by Slack API")
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "missing_scope") || strings.Contains(err.Error(), "users:read") </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Missing required OAuth scope 'users:read'\n")
                        fmt.Printf("   This scope is needed to resolve user names for message authors.\n")
                        fmt.Printf("   Add 'users:read' scope in your Slack app settings at https://api.slack.com/apps\n")
                        return fmt.Errorf("missing required OAuth scope 'users:read'")
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get users: %w", err)</span>
        }
        <span class="cov8" title="1">fmt.Printf("✅ Got %d users from API\n\n", len(userMap))

        // Parse exclusion lists
        var excludeChannelsList []string
        var excludePrefixesList []string

        if excludeChannels != "" </span><span class="cov0" title="0">{
                for _, channel := range strings.Split(excludeChannels, ",") </span><span class="cov0" title="0">{
                        channel = strings.TrimSpace(channel)
                        // Remove # prefix if present
                        if strings.HasPrefix(channel, "#") </span><span class="cov0" title="0">{
                                channel = channel[1:]
                        }</span>
                        <span class="cov0" title="0">if channel != "" </span><span class="cov0" title="0">{
                                excludeChannelsList = append(excludeChannelsList, channel)
                        }</span>
                }
        }

        <span class="cov8" title="1">if excludePrefixes != "" </span><span class="cov0" title="0">{
                for _, prefix := range strings.Split(excludePrefixes, ",") </span><span class="cov0" title="0">{
                        prefix = strings.TrimSpace(prefix)
                        // Remove # prefix if present
                        if strings.HasPrefix(prefix, "#") </span><span class="cov0" title="0">{
                                prefix = prefix[1:]
                        }</span>
                        <span class="cov0" title="0">if prefix != "" </span><span class="cov0" title="0">{
                                excludePrefixesList = append(excludePrefixesList, prefix)
                        }</span>
                }
        }

        // Show exclusion info if any are specified
        <span class="cov8" title="1">if len(excludeChannelsList) &gt; 0 || len(excludePrefixesList) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("📋 Channel exclusions configured:\n")
                if len(excludeChannelsList) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("   Excluded channels: %s\n", strings.Join(excludeChannelsList, ", "))
                }</span>
                <span class="cov0" title="0">if len(excludePrefixesList) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("   Excluded prefixes: %s\n", strings.Join(excludePrefixesList, ", "))
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov8" title="1">toWarn, toArchive, err := client.GetInactiveChannelsWithDetailsAndExclusions(warnSeconds, archiveSeconds, userMap, excludeChannelsList, excludePrefixesList)
        if err != nil </span><span class="cov8" title="1">{
                // Check if this is a rate limit error and provide helpful guidance
                if strings.Contains(err.Error(), "rate_limited") || strings.Contains(err.Error(), "rate limit") </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️  Slack API rate limit exceeded.\n")
                        fmt.Printf("   The analysis was stopped to respect API limits.\n")
                        fmt.Printf("   Please wait a few minutes before running the command again.\n")
                        fmt.Printf("   \n")
                        fmt.Printf("   Tip: Consider running with longer time periods (e.g. --warn-seconds=3600) to reduce API calls.\n")
                        return fmt.Errorf("rate limited by Slack API")
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("failed to analyze inactive channels: %w", err)</span>
        }

        // Report findings
        <span class="cov8" title="1">fmt.Printf("Inactive Channel Analysis Results:\n")
        fmt.Printf("  Channels to warn: %d\n", len(toWarn))
        fmt.Printf("  Channels to archive: %d\n", len(toArchive))
        fmt.Println()

        // Process warnings
        if len(toWarn) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("Channels to warn about inactivity:\n")
                for _, channel := range toWarn </span><span class="cov8" title="1">{
                        fmt.Printf("  #%s (inactive since: %s, members: %d)\n",
                                channel.Name,
                                channel.LastActivity.Format("2006-01-02 15:04:05"),
                                channel.MemberCount)

                        // Show last message details if available
                        if channel.LastMessage != nil </span><span class="cov8" title="1">{
                                messageText := channel.LastMessage.Text
                                if len(messageText) &gt; 60 </span><span class="cov0" title="0">{
                                        messageText = messageText[:57] + "..."
                                }</span>
                                <span class="cov8" title="1">messageText = strings.ReplaceAll(messageText, "\n", " ")

                                authorName := channel.LastMessage.UserName
                                if authorName == "" </span><span class="cov0" title="0">{
                                        authorName = channel.LastMessage.User
                                }</span>

                                <span class="cov8" title="1">botIndicator := ""
                                if channel.LastMessage.IsBot </span><span class="cov0" title="0">{
                                        botIndicator = " (bot)"
                                }</span>

                                <span class="cov8" title="1">fmt.Printf("    └─ Last message by: %s%s | \"%s\"\n", authorName, botIndicator, messageText)</span>
                        }
                }
                <span class="cov8" title="1">fmt.Println()

                if isDryRun </span><span class="cov8" title="1">{
                        fmt.Printf("--- DRY RUN ---\n")
                        fmt.Printf("Would warn %d channels about upcoming archival\n", len(toWarn))
                        if len(toWarn) &gt; 0 </span><span class="cov8" title="1">{
                                fmt.Printf("Example warning message for #%s:\n", toWarn[0].Name)
                                exampleMessage := client.FormatInactiveChannelWarning(toWarn[0], warnSeconds, archiveSeconds)
                                fmt.Printf("%s\n", exampleMessage)
                        }</span>
                        <span class="cov8" title="1">fmt.Printf("--- END DRY RUN ---\n\n")</span>
                } else<span class="cov8" title="1"> {
                        fmt.Printf("Sending warnings to %d channels (joining channels as needed)...\n", len(toWarn))
                        warningsSent := 0
                        for _, channel := range toWarn </span><span class="cov8" title="1">{
                                if err := client.WarnInactiveChannel(channel, warnSeconds, archiveSeconds); err != nil </span><span class="cov0" title="0">{
                                        logger.WithFields(logger.LogFields{
                                                "channel": channel.Name,
                                                "error":   err.Error(),
                                        }).Error("Failed to send warning")
                                        fmt.Printf("  Failed to warn #%s: %s\n", channel.Name, err.Error())
                                }</span> else<span class="cov8" title="1"> {
                                        warningsSent++
                                        logger.WithField("channel", channel.Name).Info("Warning sent successfully")
                                        fmt.Printf("  ✓ Warned #%s\n", channel.Name)
                                }</span>
                        }
                        <span class="cov8" title="1">fmt.Printf("Warnings sent: %d/%d\n\n", warningsSent, len(toWarn))</span>
                }
        }

        // Process archival
        <span class="cov8" title="1">if len(toArchive) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("Channels to archive (grace period expired):\n")
                for _, channel := range toArchive </span><span class="cov8" title="1">{
                        fmt.Printf("  #%s (inactive since: %s, members: %d)\n",
                                channel.Name,
                                channel.LastActivity.Format("2006-01-02 15:04:05"),
                                channel.MemberCount)

                        // Show last message details if available
                        if channel.LastMessage != nil </span><span class="cov8" title="1">{
                                messageText := channel.LastMessage.Text
                                if len(messageText) &gt; 60 </span><span class="cov8" title="1">{
                                        messageText = messageText[:57] + "..."
                                }</span>
                                <span class="cov8" title="1">messageText = strings.ReplaceAll(messageText, "\n", " ")

                                authorName := channel.LastMessage.UserName
                                if authorName == "" </span><span class="cov0" title="0">{
                                        authorName = channel.LastMessage.User
                                }</span>

                                <span class="cov8" title="1">botIndicator := ""
                                if channel.LastMessage.IsBot </span><span class="cov8" title="1">{
                                        botIndicator = " (bot)"
                                }</span>

                                <span class="cov8" title="1">fmt.Printf("    └─ Last message by: %s%s | \"%s\"\n", authorName, botIndicator, messageText)</span>
                        }
                }
                <span class="cov8" title="1">fmt.Println()

                if isDryRun </span><span class="cov8" title="1">{
                        fmt.Printf("--- DRY RUN ---\n")
                        fmt.Printf("Would archive %d channels\n", len(toArchive))
                        if len(toArchive) &gt; 0 </span><span class="cov8" title="1">{
                                fmt.Printf("Example archival message for #%s:\n", toArchive[0].Name)
                                exampleArchivalMessage := client.FormatChannelArchivalMessage(toArchive[0], warnSeconds, archiveSeconds)
                                fmt.Printf("%s\n", exampleArchivalMessage)
                        }</span>
                        <span class="cov8" title="1">fmt.Printf("--- END DRY RUN ---\n\n")</span>
                } else<span class="cov8" title="1"> {
                        fmt.Printf("Archiving %d channels...\n", len(toArchive))
                        archived := 0
                        for _, channel := range toArchive </span><span class="cov8" title="1">{
                                if err := client.ArchiveChannelWithThresholds(channel, warnSeconds, archiveSeconds); err != nil </span><span class="cov0" title="0">{
                                        logger.WithFields(logger.LogFields{
                                                "channel": channel.Name,
                                                "error":   err.Error(),
                                        }).Error("Failed to archive channel")
                                        fmt.Printf("  Failed to archive #%s: %s\n", channel.Name, err.Error())
                                }</span> else<span class="cov8" title="1"> {
                                        archived++
                                        logger.WithField("channel", channel.Name).Info("Channel archived successfully")
                                        fmt.Printf("  ✓ Archived #%s\n", channel.Name)
                                }</span>
                        }
                        <span class="cov8" title="1">fmt.Printf("Channels archived: %d/%d\n\n", archived, len(toArchive))</span>
                }
        }

        <span class="cov8" title="1">if len(toWarn) == 0 &amp;&amp; len(toArchive) == 0 </span><span class="cov8" title="1">{
                fmt.Printf("No inactive channels found. All channels are active or already processed.\n")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"
        "time"

        "github.com/astrostl/slack-buddy-ai/pkg/logger"
        "github.com/astrostl/slack-buddy-ai/pkg/slack"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var healthCmd = &amp;cobra.Command{
        Use:   "health",
        Short: "Check health and connectivity",
        Long: `Check the health of your Slack connection, validate configuration, and test permissions.

This command verifies:
- Token validity and format
- Slack API connectivity  
- Required OAuth scopes and permissions (channels:read, channels:join, chat:write, channels:manage, users:read)
- Bot user information
- Basic API functionality`,
        SilenceUsage: true, // Don't show usage on errors
        RunE:         runHealth,
}

var (
        healthVerbose bool
)

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(healthCmd)
        healthCmd.Flags().BoolVarP(&amp;healthVerbose, "verbose", "v", false, "Show detailed health check information")
}</span>

func runHealth(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        fmt.Println("🔍 Running health checks...")
        fmt.Println()

        // Check 1: Configuration validation
        fmt.Print("✓ Configuration validation... ")
        token := viper.GetString("token")
        if token == "" </span><span class="cov8" title="1">{
                fmt.Println("❌ FAILED")
                fmt.Println("  Error: No Slack token configured")
                fmt.Println("  Fix: Set SLACK_TOKEN environment variable or use --token flag")
                return fmt.Errorf("configuration validation failed")
        }</span>
        <span class="cov8" title="1">fmt.Println("✅ PASSED")
        if healthVerbose </span><span class="cov8" title="1">{
                fmt.Printf("  Token format: %s...%s\n", token[:8], token[len(token)-8:])
        }</span>

        // Check 2: Token format validation
        <span class="cov8" title="1">fmt.Print("✓ Token format validation... ")
        if !isValidTokenFormat(token) </span><span class="cov8" title="1">{
                fmt.Println("❌ FAILED")
                fmt.Println("  Error: Invalid token format")
                fmt.Println("  Expected: Bot tokens must start with 'xoxb-'")
                return fmt.Errorf("token format validation failed")
        }</span>
        <span class="cov8" title="1">fmt.Println("✅ PASSED")

        // Check 3: Slack client creation
        fmt.Print("✓ Slack client initialization... ")
        client, err := slack.NewClient(token)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println("❌ FAILED")
                fmt.Printf("  Error: %v\n", err)
                return fmt.Errorf("client initialization failed: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("✅ PASSED")

        // Check 4: API connectivity
        fmt.Print("✓ Slack API connectivity... ")
        authInfo, err := client.TestAuth()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("❌ FAILED")
                fmt.Printf("  Error: %v\n", err)
                fmt.Println("  Fix: Verify your token is valid and has not been revoked")
                return fmt.Errorf("API connectivity failed: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("✅ PASSED")
        if healthVerbose </span><span class="cov0" title="0">{
                fmt.Printf("  Connected as: %s (team: %s)\n", authInfo.User, authInfo.Team)
                fmt.Printf("  User ID: %s, Team ID: %s\n", authInfo.UserID, authInfo.TeamID)
        }</span>

        // Check 5: OAuth scope validation
        <span class="cov0" title="0">fmt.Print("✓ OAuth scope validation (channels:read, channels:join, chat:write, channels:manage, users:read)... ")
        if healthVerbose </span><span class="cov0" title="0">{
                fmt.Printf("\n  Testing required scopes: channels:read, channels:join, chat:write, channels:manage, users:read\n")
                fmt.Printf("  Testing optional scopes: groups:read\n")
                fmt.Print("  Validation result: ")
        }</span>
        <span class="cov0" title="0">scopes, err := client.CheckOAuthScopes()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("❌ FAILED")
                fmt.Printf("  Error: %v\n", err)
                return fmt.Errorf("scope validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">requiredScopes := map[string]bool{
                "channels:read":   true, // Required - list channels
                "channels:join":   true, // Required - join channels for warnings
                "chat:write":      true, // Required - post warning messages
                "channels:manage": true, // Required - archive channels
                "users:read":      true, // Required - resolve user names for message authors
        }
        optionalScopes := map[string]bool{
                "groups:read": false, // Optional - access private channels
        }

        var missingRequired []string
        var missingOptional []string

        for scope := range requiredScopes </span><span class="cov0" title="0">{
                if !scopes[scope] </span><span class="cov0" title="0">{
                        missingRequired = append(missingRequired, scope)
                }</span>
        }

        <span class="cov0" title="0">for scope := range optionalScopes </span><span class="cov0" title="0">{
                if !scopes[scope] </span><span class="cov0" title="0">{
                        missingOptional = append(missingOptional, scope)
                }</span>
        }

        <span class="cov0" title="0">if len(missingRequired) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("❌ FAILED")
                fmt.Println("  Missing REQUIRED OAuth scopes:")
                for _, scope := range missingRequired </span><span class="cov0" title="0">{
                        fmt.Printf("    - %s\n", scope)
                }</span>
                <span class="cov0" title="0">if len(missingOptional) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("  Missing OPTIONAL OAuth scopes:")
                        for _, scope := range missingOptional </span><span class="cov0" title="0">{
                                fmt.Printf("    - %s (private channels won't be accessible)\n", scope)
                        }</span>
                }
                <span class="cov0" title="0">fmt.Println("  Fix: Add missing OAuth scopes in your Slack app settings at https://api.slack.com/apps")
                return fmt.Errorf("missing required OAuth scopes")</span>
        }

        <span class="cov0" title="0">fmt.Println("✅ PASSED")
        if healthVerbose </span><span class="cov0" title="0">{
                fmt.Println("  OAuth scope test results:")

                // Show required scopes first
                fmt.Println("    Required scopes:")
                for scope := range requiredScopes </span><span class="cov0" title="0">{
                        status := "❌"
                        if scopes[scope] </span><span class="cov0" title="0">{
                                status = "✅"
                        }</span>
                        <span class="cov0" title="0">var testMethod string
                        switch scope </span>{
                        case "channels:read":<span class="cov0" title="0">
                                testMethod = "tested with GetConversations()"</span>
                        case "channels:join":<span class="cov0" title="0">
                                testMethod = "tested with JoinConversation()"</span>
                        case "chat:write":<span class="cov0" title="0">
                                testMethod = "tested with PostMessage()"</span>
                        case "channels:manage":<span class="cov0" title="0">
                                testMethod = "tested with ArchiveConversation()"</span>
                        case "users:read":<span class="cov0" title="0">
                                testMethod = "tested with GetUsers()"</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("      %s %s - %s\n", status, scope, testMethod)</span>
                }

                // Show optional scopes
                <span class="cov0" title="0">fmt.Println("    Optional scopes:")
                for scope := range optionalScopes </span><span class="cov0" title="0">{
                        status := "❌"
                        if scopes[scope] </span><span class="cov0" title="0">{
                                status = "✅"
                        }</span>
                        <span class="cov0" title="0">var testMethod string
                        switch scope </span>{
                        case "groups:read":<span class="cov0" title="0">
                                testMethod = "tested with GetConversations(private_channel)"</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("      %s %s - %s\n", status, scope, testMethod)</span>
                }
        }

        <span class="cov0" title="0">if len(missingOptional) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("  ⚠️  Note: Some optional scopes are missing - private channels won't be accessible")
        }</span>

        // Check 6: Basic functionality test
        <span class="cov0" title="0">fmt.Print("✓ Basic functionality test... ")
        if err := testBasicFunctionality(client); err != nil </span><span class="cov0" title="0">{
                fmt.Println("⚠️  WARNING")
                fmt.Printf("  Warning: %v\n", err)
                fmt.Println("  Note: Basic connectivity works, but some features may be limited")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("✅ PASSED")
        }</span>

        <span class="cov0" title="0">fmt.Println()
        fmt.Println("🎉 Health check completed successfully!")
        fmt.Printf("   Connected as: %s (team: %s)\n", authInfo.User, authInfo.Team)
        fmt.Println("   All systems operational")

        return nil</span>
}

func isValidTokenFormat(token string) bool <span class="cov8" title="1">{
        return len(token) &gt; 8 &amp;&amp; (token[:5] == "xoxb-" || token[:5] == "xoxp-")
}</span>

func testBasicFunctionality(client *slack.Client) error <span class="cov8" title="1">{
        // Test getting channel list with a reasonable timeout
        logger.WithField("operation", "health_check").Debug("Testing basic channel listing functionality")

        cutoffTime := time.Now().Add(-24 * time.Hour)
        channels, err := client.GetNewChannels(cutoffTime)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("channel listing test failed: %w", err)
        }</span>

        <span class="cov8" title="1">if healthVerbose </span><span class="cov8" title="1">{
                fmt.Printf("  Successfully retrieved channel information (%d channels checked)\n", len(channels))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func contains(s, substr string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(substr) &amp;&amp;
                (len(substr) == 0 ||
                        (len(s) &gt; 0 &amp;&amp;
                                (s == substr ||
                                        (len(s) &gt; len(substr) &amp;&amp;
                                                (s[:len(substr)] == substr ||
                                                        s[len(s)-len(substr):] == substr ||
                                                        containsSubstring(s, substr))))))
}</span>

func containsSubstring(s, substr string) bool <span class="cov8" title="1">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov8" title="1">{
                if s[i:i+len(substr)] == substr </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/astrostl/slack-buddy-ai/pkg/logger"

        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

// Version information passed from main.
var (
        version   string
        buildTime string
        gitCommit string
)

var rootCmd = &amp;cobra.Command{
        Use:   "slack-buddy",
        Short: "A CLI tool to help manage Slack workspaces",
        Long:  `Slack Buddy is a CLI tool that helps make Slack workspaces more useful and tidy.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov8" title="1">{
                // Handle --version flag when no subcommand is specified
                if versionFlag, _ := cmd.Flags().GetBool("version"); versionFlag </span><span class="cov8" title="1">{
                        fmt.Printf("slack-buddy version %s\n", version)
                        if buildTime != "unknown" </span><span class="cov8" title="1">{
                                fmt.Printf("Built: %s\n", buildTime)
                        }</span>
                        <span class="cov8" title="1">if gitCommit != "unknown" </span><span class="cov8" title="1">{
                                fmt.Printf("Commit: %s\n", gitCommit)
                        }</span>
                        <span class="cov8" title="1">return</span>
                }
                // Show help if no version flag and no subcommand
                <span class="cov0" title="0">_ = cmd.Help()</span>
        },
        CompletionOptions: cobra.CompletionOptions{
                DisableDefaultCmd: true,
        },
}

func Execute(ver, build, commit string) <span class="cov8" title="1">{
        // Store version information for use in commands
        version = ver
        buildTime = build
        gitCommit = commit

        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // Cobra already displays the error, no need to log it again
                os.Exit(1)
        }</span>
}

func init() <span class="cov8" title="1">{
        cobra.OnInitialize(initConfig)

        // Global flags
        rootCmd.PersistentFlags().String("token", "", "Slack bot token (can also be set via SLACK_TOKEN env var)")
        rootCmd.PersistentFlags().BoolP("debug", "d", false, "Enable debug logging")
        rootCmd.Flags().BoolP("version", "v", false, "Print version information")

        // Bind flags to viper
        if err := viper.BindPFlag("token", rootCmd.PersistentFlags().Lookup("token")); err != nil </span><span class="cov0" title="0">{
                logger.WithField("error", err.Error()).Fatal("Failed to bind token flag")
        }</span>
        <span class="cov8" title="1">if err := viper.BindPFlag("debug", rootCmd.PersistentFlags().Lookup("debug")); err != nil </span><span class="cov0" title="0">{
                logger.WithField("error", err.Error()).Fatal("Failed to bind debug flag")
        }</span>

}

func initConfig() <span class="cov8" title="1">{
        viper.SetEnvPrefix("SLACK")
        viper.AutomaticEnv()

        // Explicitly bind environment variables
        _ = viper.BindEnv("token", "SLACK_TOKEN")
        _ = viper.BindEnv("debug", "SLACK_DEBUG")

        // Set log level based on debug flag
        if viper.GetBool("debug") </span><span class="cov0" title="0">{
                logger.Log.SetLevel(logrus.DebugLevel)
        }</span> else<span class="cov8" title="1"> {
                logger.Log.SetLevel(logrus.InfoLevel)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Print version information",
        Long:  `Display version information including build time and git commit.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov8" title="1">{
                fmt.Printf("slack-buddy version %s\n", version)
                if buildTime != "unknown" </span><span class="cov8" title="1">{
                        fmt.Printf("Built: %s\n", buildTime)
                }</span>
                <span class="cov8" title="1">if gitCommit != "unknown" </span><span class="cov8" title="1">{
                        fmt.Printf("Commit: %s\n", gitCommit)
                }</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(versionCmd)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "github.com/astrostl/slack-buddy-ai/cmd"
)

// Version information injected at build time via GoReleaser.
var (
        Version   = "dev"     // Version is the application version
        BuildTime = "unknown" // BuildTime is when the binary was built
        GitCommit = "unknown" // GitCommit is the git commit hash
)

func main() <span class="cov0" title="0">{
        cmd.Execute(Version, BuildTime, GitCommit)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package logger

import (
        "os"

        "github.com/sirupsen/logrus"
)

// LogFields is an alias for logrus.Fields for convenience.
type LogFields = logrus.Fields

var Log *logrus.Logger

func init() <span class="cov8" title="1">{
        Log = logrus.New()

        // Set output to stdout
        Log.SetOutput(os.Stdout)

        // Set log level based on environment (default to Info)
        level := os.Getenv("SLACK_LOG_LEVEL")
        switch level </span>{
        case "debug":<span class="cov0" title="0">
                Log.SetLevel(logrus.DebugLevel)</span>
        case "warn":<span class="cov0" title="0">
                Log.SetLevel(logrus.WarnLevel)</span>
        case "error":<span class="cov0" title="0">
                Log.SetLevel(logrus.ErrorLevel)</span>
        default:<span class="cov8" title="1">
                Log.SetLevel(logrus.InfoLevel)</span>
        }

        // Use JSON formatter for production, text for development
        <span class="cov8" title="1">format := os.Getenv("SLACK_LOG_FORMAT")
        if format == "json" </span><span class="cov0" title="0">{
                Log.SetFormatter(&amp;logrus.JSONFormatter{
                        TimestampFormat: "2006-01-02 15:04:05",
                })
        }</span> else<span class="cov8" title="1"> {
                Log.SetFormatter(&amp;logrus.TextFormatter{
                        FullTimestamp:   true,
                        TimestampFormat: "2006-01-02 15:04:05",
                        DisableColors:   os.Getenv("SLACK_LOG_NO_COLOR") == "true",
                })
        }</span>
}

// GetLogger returns the configured logger instance.
func GetLogger() *logrus.Logger <span class="cov8" title="1">{
        return Log
}</span>

// WithFields creates a new logger entry with structured fields.
func WithFields(fields logrus.Fields) *logrus.Entry <span class="cov8" title="1">{
        return Log.WithFields(fields)
}</span>

// WithField creates a new logger entry with a single structured field.
func WithField(key string, value interface{}) *logrus.Entry <span class="cov8" title="1">{
        return Log.WithField(key, value)
}</span>

// Info logs an info message.
func Info(msg string) <span class="cov8" title="1">{
        Log.Info(msg)
}</span>

// Debug logs a debug message.
func Debug(msg string) <span class="cov8" title="1">{
        Log.Debug(msg)
}</span>

// Warn logs a warning message.
func Warn(msg string) <span class="cov8" title="1">{
        Log.Warn(msg)
}</span>

// Error logs an error message.
func Error(msg string) <span class="cov8" title="1">{
        Log.Error(msg)
}</span>

// Fatal logs a fatal message and exits.
func Fatal(msg string) <span class="cov0" title="0">{
        Log.Fatal(msg)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package slack

import (
        "context"
        "fmt"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/astrostl/slack-buddy-ai/pkg/logger"

        "github.com/slack-go/slack"
)

// Common time duration text constants
const (
        oneMinuteText = "1 minute"
        oneHourText   = "1 hour"
        oneDayText    = "1 day"
)

type RateLimiter struct {
        lastRequest  time.Time
        minInterval  time.Duration
        backoffCount int
        maxBackoff   time.Duration
        mu           sync.Mutex
}

type Client struct {
        api         SlackAPI
        rateLimiter *RateLimiter
}

type Channel struct {
        ID           string
        Name         string
        Created      time.Time
        Updated      time.Time
        Purpose      string
        Creator      string
        LastActivity time.Time
        MemberCount  int
        IsArchived   bool
        LastMessage  *MessageInfo // Optional: details about the last message
}

type AuthInfo struct {
        User   string
        UserID string
        Team   string
        TeamID string
}

func NewClient(token string) (*Client, error) <span class="cov8" title="1">{
        // Validate token format before using it
        if err := ValidateSlackToken(token); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid token: %w", err)
        }</span>

        <span class="cov8" title="1">api := NewRealSlackAPI(token)

        auth, err := api.AuthTest()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("authentication failed: %v", SanitizeForLogging(err.Error()))
        }</span>

        <span class="cov0" title="0">logger.WithFields(logger.LogFields{
                "user": auth.User,
                "team": auth.Team,
        }).Debug("Successfully connected to Slack")
        // Connection info logged but not printed to reduce output noise
        return &amp;Client{
                api: api,
                rateLimiter: &amp;RateLimiter{
                        minInterval: time.Second,      // 1 request per second baseline
                        maxBackoff:  time.Second * 30, // Max 30 second backoff (test-friendly)
                },
        }, nil</span>
}

// NewClientWithAPI creates a client with a custom API implementation (for testing).
func NewClientWithAPI(api SlackAPI) (*Client, error) <span class="cov8" title="1">{
        if api == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("API cannot be nil")
        }</span>

        <span class="cov8" title="1">auth, err := api.AuthTest()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("authentication failed: %w", err)
        }</span>

        <span class="cov8" title="1">logger.WithFields(logger.LogFields{
                "user": auth.User,
                "team": auth.Team,
        }).Debug("Successfully connected to Slack")
        // Connection info logged but not printed to reduce output noise
        return &amp;Client{
                api: api,
                rateLimiter: &amp;RateLimiter{
                        minInterval: time.Second,      // 1 request per second baseline
                        maxBackoff:  time.Second * 30, // Max 30 second backoff (test-friendly)
                },
        }, nil</span>
}

func (rl *RateLimiter) Wait(ctx context.Context) error <span class="cov8" title="1">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        now := time.Now()
        timeSinceLastRequest := now.Sub(rl.lastRequest)

        // Calculate wait time with exponential backoff
        waitTime := rl.minInterval
        if rl.backoffCount &gt; 0 </span><span class="cov8" title="1">{
                backoffMultiplier := time.Duration(1 &lt;&lt; rl.backoffCount) // 2^backoffCount
                waitTime = rl.minInterval * backoffMultiplier
                if waitTime &gt; rl.maxBackoff </span><span class="cov0" title="0">{
                        waitTime = rl.maxBackoff
                }</span>
        }

        <span class="cov8" title="1">if timeSinceLastRequest &lt; waitTime </span><span class="cov8" title="1">{
                sleepTime := waitTime - timeSinceLastRequest
                logger.WithFields(logger.LogFields{
                        "sleep_duration": sleepTime.String(),
                        "backoff_count":  rl.backoffCount,
                }).Debug("Rate limiting: sleeping before API request")

                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                case &lt;-time.After(sleepTime):<span class="cov8" title="1"></span>
                }
        }

        <span class="cov8" title="1">rl.lastRequest = time.Now()
        return nil</span>
}

func (rl *RateLimiter) OnSuccess() <span class="cov8" title="1">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        // Reset backoff on successful request
        if rl.backoffCount &gt; 0 </span><span class="cov8" title="1">{
                logger.WithField("previous_backoff", rl.backoffCount).Debug("Rate limiting: resetting backoff after success")
                rl.backoffCount = 0
        }</span>
}

func (rl *RateLimiter) OnRateLimitError() <span class="cov8" title="1">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        rl.backoffCount++
        if rl.backoffCount &gt; 6 </span><span class="cov8" title="1">{ // Cap at 2^6 = 64 seconds
                rl.backoffCount = 6
        }</span>

        <span class="cov8" title="1">logger.WithField("backoff_count", rl.backoffCount).Warn("Rate limiting: increasing backoff due to rate limit error")</span>
}

func (c *Client) GetNewChannels(since time.Time) ([]Channel, error) <span class="cov8" title="1">{
        logger.WithField("since", since.Format("2006-01-02 15:04:05")).Debug("Fetching channels from Slack API")

        // Apply rate limiting
        ctx, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()
        if err := c.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rate limiter cancelled: %w", err)
        }</span>

        <span class="cov8" title="1">channels, _, err := c.api.GetConversations(&amp;slack.GetConversationsParameters{
                Types: []string{"public_channel", "private_channel"},
                Limit: 1000,
        })
        if err != nil </span><span class="cov8" title="1">{
                errStr := err.Error()
                logger.WithFields(logger.LogFields{
                        "error":     errStr,
                        "operation": "get_conversations",
                }).Error("Slack API error")

                // Handle rate limiting
                if strings.Contains(errStr, "rate_limited") </span><span class="cov8" title="1">{
                        c.rateLimiter.OnRateLimitError()
                        return nil, fmt.Errorf("rate limited by Slack API. Will retry with exponential backoff on next request")
                }</span>

                <span class="cov8" title="1">if strings.Contains(errStr, "missing_scope") </span><span class="cov8" title="1">{
                        logger.Error("Missing OAuth scopes for channel access")
                        return nil, fmt.Errorf("missing required permissions. Your bot needs these OAuth scopes:\n  - channels:read (to list public channels) - REQUIRED\n  - groups:read (to list private channels) - OPTIONAL\n\nPlease add these scopes in your Slack app settings at https://api.slack.com/apps")
                }</span>
                <span class="cov8" title="1">if strings.Contains(errStr, "invalid_auth") </span><span class="cov8" title="1">{
                        logger.Error("Invalid Slack authentication token")
                        return nil, fmt.Errorf("invalid token. Please check your SLACK_TOKEN")
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("failed to get conversations: %w", err)</span>
        }

        // Mark successful API call
        <span class="cov8" title="1">c.rateLimiter.OnSuccess()

        logger.WithField("total_channels", len(channels)).Debug("Retrieved channels from Slack API")

        var newChannels []Channel
        for _, ch := range channels </span><span class="cov8" title="1">{
                created := time.Unix(int64(ch.Created), 0)
                if created.After(since) </span><span class="cov8" title="1">{
                        logger.WithFields(logger.LogFields{
                                "channel_id":   ch.ID,
                                "channel_name": ch.Name,
                                "created":      created.Format("2006-01-02 15:04:05"),
                        }).Debug("Found new channel")

                        newChannels = append(newChannels, Channel{
                                ID:      ch.ID,
                                Name:    ch.Name,
                                Created: created,
                                Purpose: ch.Purpose.Value,
                                Creator: ch.Creator,
                        })
                }</span>
        }

        <span class="cov8" title="1">logger.WithField("new_channels_count", len(newChannels)).Debug("Channel detection completed")
        return newChannels, nil</span>
}

func (c *Client) GetNewChannelsWithAllChannels(since time.Time) ([]Channel, []slack.Channel, error) <span class="cov0" title="0">{
        logger.WithField("since", since.Format("2006-01-02 15:04:05")).Debug("Fetching channels from Slack API")

        channels, _, err := c.api.GetConversations(&amp;slack.GetConversationsParameters{
                Types: []string{"public_channel", "private_channel"},
                Limit: 1000,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get conversations: %w", err)
        }</span>

        <span class="cov0" title="0">logger.WithField("total_channels", len(channels)).Debug("Retrieved channels from Slack API")

        var newChannels []Channel
        for _, ch := range channels </span><span class="cov0" title="0">{
                created := time.Unix(int64(ch.Created), 0)
                if created.After(since) </span><span class="cov0" title="0">{
                        logger.WithFields(logger.LogFields{
                                "channel_id":   ch.ID,
                                "channel_name": ch.Name,
                                "created":      created.Format("2006-01-02 15:04:05"),
                        }).Debug("Found new channel")

                        newChannels = append(newChannels, Channel{
                                ID:      ch.ID,
                                Name:    ch.Name,
                                Created: created,
                                Creator: ch.Creator,
                                Purpose: ch.Purpose.Value,
                        })
                }</span>
        }

        <span class="cov0" title="0">logger.WithField("new_channels_count", len(newChannels)).Debug("Channel detection completed")
        return newChannels, channels, nil</span>
}

func (c *Client) FormatNewChannelAnnouncement(channels []Channel, since time.Time) string <span class="cov8" title="1">{
        logger.WithFields(logger.LogFields{
                "channel_count": len(channels),
                "since":         since.Format("2006-01-02 15:04:05"),
        }).Debug("Formatting announcement message")

        var builder strings.Builder

        if len(channels) == 1 </span><span class="cov8" title="1">{
                builder.WriteString("New channel alert!")
        }</span> else<span class="cov8" title="1"> {
                builder.WriteString(fmt.Sprintf("%d new channels created!", len(channels)))
        }</span>

        <span class="cov8" title="1">builder.WriteString("\n\n")

        for i, ch := range channels </span><span class="cov8" title="1">{
                builder.WriteString(fmt.Sprintf("• &lt;#%s&gt;", ch.ID))

                // Add creator info if available
                if ch.Creator != "" </span><span class="cov8" title="1">{
                        builder.WriteString(fmt.Sprintf(" created by &lt;@%s&gt;", ch.Creator))
                }</span>

                <span class="cov8" title="1">if ch.Purpose != "" </span><span class="cov8" title="1">{
                        builder.WriteString(fmt.Sprintf("\n  Purpose: %s", ch.Purpose))
                }</span>

                // Add spacing between channels (but not after the last one)
                <span class="cov8" title="1">if i &lt; len(channels)-1 </span><span class="cov8" title="1">{
                        builder.WriteString("\n\n")
                }</span> else<span class="cov8" title="1"> {
                        builder.WriteString("\n")
                }</span>
        }

        <span class="cov8" title="1">return builder.String()</span>
}

func (c *Client) FormatNewChannelAnnouncementDryRun(channels []Channel, since time.Time) string <span class="cov0" title="0">{
        // Get user map for resolving creator names
        userMap, err := c.GetUserMap()
        if err != nil </span><span class="cov0" title="0">{
                // If we can't get users, fall back to regular format
                return c.FormatNewChannelAnnouncement(channels, since)
        }</span>

        <span class="cov0" title="0">var builder strings.Builder

        if len(channels) == 1 </span><span class="cov0" title="0">{
                builder.WriteString("New channel alert!")
        }</span> else<span class="cov0" title="0"> {
                builder.WriteString(fmt.Sprintf("%d new channels created!", len(channels)))
        }</span>

        <span class="cov0" title="0">builder.WriteString("\n\n")

        for i, ch := range channels </span><span class="cov0" title="0">{
                builder.WriteString(fmt.Sprintf("• #%s", ch.Name))

                // Add creator info with pretty name if available
                if ch.Creator != "" </span><span class="cov0" title="0">{
                        creatorName := ch.Creator // fallback to ID
                        if userName, exists := userMap[ch.Creator]; exists &amp;&amp; userName != "" </span><span class="cov0" title="0">{
                                creatorName = userName
                        }</span>
                        <span class="cov0" title="0">builder.WriteString(fmt.Sprintf(" created by %s", creatorName))</span>
                }

                <span class="cov0" title="0">if ch.Purpose != "" </span><span class="cov0" title="0">{
                        builder.WriteString(fmt.Sprintf("\n  Purpose: %s", ch.Purpose))
                }</span>

                // Add spacing between channels (but not after the last one)
                <span class="cov0" title="0">if i &lt; len(channels)-1 </span><span class="cov0" title="0">{
                        builder.WriteString("\n\n")
                }</span> else<span class="cov0" title="0"> {
                        builder.WriteString("\n")
                }</span>
        }

        <span class="cov0" title="0">return builder.String()</span>
}

func (c *Client) CheckForDuplicateAnnouncement(channel, newMessage string, channelNames []string) (bool, error) <span class="cov0" title="0">{
        // Use a default cutoff of 30 days ago for backward compatibility
        cutoffTime := time.Now().Add(-30 * 24 * time.Hour)
        isDuplicate, _, err := c.CheckForDuplicateAnnouncementWithDetails(channel, newMessage, channelNames, cutoffTime)
        return isDuplicate, err
}</span>

func (c *Client) CheckForDuplicateAnnouncementWithDetails(channel, newMessage string, channelNames []string, cutoffTime time.Time) (bool, []string, error) <span class="cov0" title="0">{
        // Use empty channel list - will make API call to get channels
        return c.CheckForDuplicateAnnouncementWithDetailsAndChannels(channel, newMessage, channelNames, cutoffTime, nil)
}</span>

func (c *Client) CheckForDuplicateAnnouncementWithDetailsAndChannels(channel, newMessage string, channelNames []string, cutoffTime time.Time, allChannels []slack.Channel) (bool, []string, error) <span class="cov0" title="0">{
        logger.WithFields(logger.LogFields{
                "channel":      channel,
                "channel_list": strings.Join(channelNames, ", "),
        }).Debug("Checking for duplicate announcements")

        // Resolve channel name to channel ID
        channelID, err := c.ResolveChannelNameToID(channel)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("failed to find channel %s: %w", channel, err)
        }</span>

        // Create name-to-ID mapping from provided channels or fetch if not provided
        <span class="cov0" title="0">var channelNameToID map[string]string
        if allChannels != nil </span><span class="cov0" title="0">{
                // Use provided channel list
                channelNameToID = make(map[string]string)
                for _, ch := range allChannels </span><span class="cov0" title="0">{
                        channelNameToID[ch.Name] = ch.ID
                }</span>
        } else<span class="cov0" title="0"> {
                // Fallback: get channels via API call
                var err error
                channelNameToID, err = c.getAllChannelNameToIDMap()
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithFields(logger.LogFields{
                                "error": err.Error(),
                        }).Warn("Failed to get channel mappings for duplicate detection, will use name-only matching")
                        channelNameToID = make(map[string]string)
                }</span>
        }

        // Get our bot's auth info to identify our messages
        <span class="cov0" title="0">authInfo, err := c.TestAuth()
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("failed to get auth info: %w", err)
        }</span>

        // Due to Slack API limits (15 messages max, 1 req/min), just get the last 15 messages
        // No time window - work with whatever we can get
        <span class="cov0" title="0">params := &amp;slack.GetConversationHistoryParameters{
                ChannelID: channelID,
                Limit:     15, // Explicit limit to match API restriction
        }

        // Retry on Slack rate limits but not with artificial delays
        const maxRetries = 3
        var history *slack.GetConversationHistoryResponse

        for attempt := 1; attempt &lt;= maxRetries; attempt++ </span><span class="cov0" title="0">{
                var err error
                history, err = c.api.GetConversationHistory(params)
                if err != nil </span><span class="cov0" title="0">{
                        errStr := err.Error()
                        // Only retry on Slack's rate limiting
                        if strings.Contains(errStr, "rate_limited") || strings.Contains(errStr, "rate limit") </span><span class="cov0" title="0">{
                                if attempt &lt; maxRetries </span><span class="cov0" title="0">{
                                        // Parse Slack's retry-after directive (already includes buffer)
                                        waitDuration := parseSlackRetryAfter(errStr)
                                        if waitDuration &gt; 0 </span><span class="cov0" title="0">{
                                                logger.WithFields(logger.LogFields{
                                                        "channel": channel,
                                                        "attempt": attempt,
                                                        "wait_duration": waitDuration.String(),
                                                }).Info("Respecting Slack rate limit for duplicate check")
                                                fmt.Printf("⏳ Waiting %s due to Slack rate limit (attempt %d/%d)...\n", waitDuration.String(), attempt, maxRetries)
                                                showProgressBar(waitDuration)
                                                fmt.Println() // Add newline after progress bar
                                                continue</span>
                                        }
                                }
                        }
                        // For non-rate-limit errors or final attempt
                        <span class="cov0" title="0">logger.WithFields(logger.LogFields{
                                "channel": channel,
                                "error":   errStr,
                        }).Warn("Failed to get channel history for duplicate check")
                        return false, nil, nil</span>
                }
                // Success - break out of retry loop
                <span class="cov0" title="0">break</span>
        }

        // Check each message to see if it's from our bot and collect all announced channels
        <span class="cov0" title="0">var allAnnouncedChannels []string
        var foundDuplicates bool

        
        for _, message := range history.Messages </span><span class="cov0" title="0">{
                // Skip if not from our bot
                if message.User != authInfo.UserID &amp;&amp; message.BotID != authInfo.UserID </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if duplicateChannels := c.findDuplicateChannelsInMessageWithIDs(message.Text, channelNames, channelNameToID); len(duplicateChannels) &gt; 0 </span><span class="cov0" title="0">{
                        logger.WithFields(logger.LogFields{
                                "channel":          channel,
                                "duplicate_ts":     message.Timestamp,
                                "announced_channels": strings.Join(duplicateChannels, ", "),
                        }).Debug("Found duplicate announcement")
                        
                        // Add these channels to our list of announced channels
                        for _, dupChannel := range duplicateChannels </span><span class="cov0" title="0">{
                                // Avoid duplicates in our list
                                alreadyInList := false
                                for _, existing := range allAnnouncedChannels </span><span class="cov0" title="0">{
                                        if existing == dupChannel </span><span class="cov0" title="0">{
                                                alreadyInList = true
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if !alreadyInList </span><span class="cov0" title="0">{
                                        allAnnouncedChannels = append(allAnnouncedChannels, dupChannel)
                                }</span>
                        }
                        <span class="cov0" title="0">foundDuplicates = true</span>
                }
        }

        <span class="cov0" title="0">if foundDuplicates </span><span class="cov0" title="0">{
                return true, allAnnouncedChannels, nil
        }</span>

        <span class="cov0" title="0">logger.WithFields(logger.LogFields{
                "channel":      channel,
                "scanned_msgs": len(history.Messages),
        }).Debug("No duplicate announcements found")
        return false, nil, nil</span>
}

func (c *Client) messageContainsSameChannels(messageText string, channelNames []string) bool <span class="cov0" title="0">{
        return len(c.findDuplicateChannelsInMessage(messageText, channelNames)) &gt; 0
}</span>

func (c *Client) findDuplicateChannelsInMessage(messageText string, channelNames []string) []string <span class="cov0" title="0">{
        // Legacy function - creates empty ID map for backward compatibility
        return c.findDuplicateChannelsInMessageWithIDs(messageText, channelNames, make(map[string]string))
}</span>

func (c *Client) findDuplicateChannelsInMessageWithIDs(messageText string, channelNames []string, channelNameToID map[string]string) []string <span class="cov0" title="0">{
        var duplicates []string
        // Look for channel mentions in the format &lt;#CHANNELID&gt; or #channelname
        for _, channelName := range channelNames </span><span class="cov0" title="0">{
                // Check for #channelname format
                if strings.Contains(messageText, "#"+channelName) </span><span class="cov0" title="0">{
                        duplicates = append(duplicates, channelName)
                        continue</span>
                }
                
                // Check for &lt;#CHANNELID&gt; format using pre-resolved IDs
                <span class="cov0" title="0">if channelID, exists := channelNameToID[channelName]; exists </span><span class="cov0" title="0">{
                        if strings.Contains(messageText, "&lt;#"+channelID+"&gt;") </span><span class="cov0" title="0">{
                                duplicates = append(duplicates, channelName)
                        }</span>
                }
        }

        <span class="cov0" title="0">return duplicates</span>
}

func (c *Client) getAllChannelNameToIDMap() (map[string]string, error) <span class="cov0" title="0">{
        // Rate limit before API call
        ctx, cancel := context.WithTimeout(context.Background(), time.Minute*2)
        defer cancel()

        if err := c.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rate limiter cancelled: %w", err)
        }</span>

        // Get all channels in one API call
        <span class="cov0" title="0">params := &amp;slack.GetConversationsParameters{
                Types: []string{"public_channel", "private_channel"},
                Limit: 1000,
        }

        channels, _, err := c.api.GetConversations(params)
        if err != nil </span><span class="cov0" title="0">{
                c.rateLimiter.OnRateLimitError()
                return nil, fmt.Errorf("failed to get conversations: %w", err)
        }</span>

        <span class="cov0" title="0">c.rateLimiter.OnSuccess()

        // Create name-to-ID mapping
        nameToID := make(map[string]string)
        for _, channel := range channels </span><span class="cov0" title="0">{
                nameToID[channel.Name] = channel.ID
        }</span>

        <span class="cov0" title="0">return nameToID, nil</span>
}

func (c *Client) PostMessage(channel, message string) error <span class="cov8" title="1">{
        logger.WithFields(logger.LogFields{
                "channel":        channel,
                "message_length": len(message),
        }).Debug("Attempting to post message to channel")

        // Validate channel name format
        if err := ValidateChannelName(channel); err != nil </span><span class="cov8" title="1">{
                logger.WithFields(logger.LogFields{
                        "channel": channel,
                        "error":   err.Error(),
                }).Error("Invalid channel name format")
                return fmt.Errorf("invalid channel name '%s': %w", channel, err)
        }</span>

        // Resolve channel name to channel ID
        <span class="cov8" title="1">channelID, err := c.ResolveChannelNameToID(channel)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to find channel %s: %w", channel, err)
        }</span>

        // Rate limit before API call
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        if err := c.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("rate limiter cancelled: %w", err)
        }</span>

        <span class="cov8" title="1">_, _, err = c.api.PostMessage(channelID, slack.MsgOptionText(message, false))
        if err != nil </span><span class="cov8" title="1">{
                errStr := err.Error()
                logger.WithFields(logger.LogFields{
                        "channel":   channel,
                        "error":     errStr,
                        "operation": "post_message",
                }).Error("Failed to post message to Slack")

                // Handle rate limiting
                if strings.Contains(errStr, "rate_limited") </span><span class="cov8" title="1">{
                        c.rateLimiter.OnRateLimitError()
                        return fmt.Errorf("rate limited by Slack API. Will retry with exponential backoff on next request")
                }</span>

                <span class="cov8" title="1">if strings.Contains(errStr, "missing_scope") </span><span class="cov8" title="1">{
                        logger.Error("Missing chat:write OAuth scope")
                        return fmt.Errorf("missing required permission to post messages. Your bot needs the 'chat:write' OAuth scope.\nPlease add this scope in your Slack app settings at https://api.slack.com/apps")
                }</span>
                <span class="cov8" title="1">if strings.Contains(errStr, "channel_not_found") </span><span class="cov0" title="0">{
                        logger.WithField("channel", channel).Error("Channel not found")
                        return fmt.Errorf("channel '%s' not found. Make sure the bot is added to the channel", channel)
                }</span>
                <span class="cov8" title="1">if strings.Contains(errStr, "not_in_channel") </span><span class="cov8" title="1">{
                        logger.WithField("channel", channel).Error("Bot not in channel")
                        return fmt.Errorf("bot is not a member of channel '%s'. Please add the bot to the channel", channel)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("failed to post message to %s: %w", channel, err)</span>
        }

        // Mark successful API call
        <span class="cov8" title="1">c.rateLimiter.OnSuccess()

        logger.WithField("channel", channel).Debug("Message posted successfully")
        return nil</span>
}

func (c *Client) TestAuth() (*AuthInfo, error) <span class="cov8" title="1">{
        auth, err := c.api.AuthTest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;AuthInfo{
                User:   auth.User,
                UserID: auth.UserID,
                Team:   auth.Team,
                TeamID: auth.TeamID,
        }, nil</span>
}

func (c *Client) CheckOAuthScopes() (map[string]bool, error) <span class="cov8" title="1">{
        _, err := c.api.AuthTest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to authenticate: %w", err)
        }</span>

        // Test each required scope individually by trying operations that require them
        // This is more reliable than trying to parse scope information from auth response

        <span class="cov8" title="1">scopeResults := make(map[string]bool)

        // Test each required scope individually by trying operations that require them
        scopeResults["channels:read"] = c.testChannelsReadScope()
        scopeResults["channels:join"] = c.testChannelsJoinScope()
        scopeResults["chat:write"] = c.testChatWriteScope()
        scopeResults["channels:manage"] = c.testChannelsManageScope()
        scopeResults["users:read"] = c.testUsersReadScope()
        scopeResults["groups:read"] = c.testGroupsReadScope() // Optional for private channels

        return scopeResults, nil</span>
}

func (c *Client) testChannelsReadScope() bool <span class="cov8" title="1">{
        // Try to get conversations - this requires channels:read
        _, _, err := c.api.GetConversations(&amp;slack.GetConversationsParameters{
                Types: []string{"public_channel"},
                Limit: 1,
        })

        if err != nil &amp;&amp; strings.Contains(err.Error(), "missing_scope") </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func (c *Client) testChannelsJoinScope() bool <span class="cov8" title="1">{
        // We can't easily test this without actually trying to join a channel
        // For now, we'll assume it's available if channels:read works
        // In a real scenario, this would be tested when actually trying to join
        return true
}</span>

func (c *Client) testChatWriteScope() bool <span class="cov8" title="1">{
        // We can't test this without actually posting a message
        // For now, we'll assume it's available - it will be tested when actually posting
        return true
}</span>

func (c *Client) testChannelsManageScope() bool <span class="cov8" title="1">{
        // We can't test this without actually trying to archive a channel
        // For now, we'll assume it's available - it will be tested when actually archiving
        return true
}</span>

func (c *Client) testGroupsReadScope() bool <span class="cov8" title="1">{
        // Try to get private channels - this requires groups:read (optional)
        _, _, err := c.api.GetConversations(&amp;slack.GetConversationsParameters{
                Types: []string{"private_channel"},
                Limit: 1,
        })

        if err != nil &amp;&amp; strings.Contains(err.Error(), "missing_scope") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func (c *Client) testUsersReadScope() bool <span class="cov8" title="1">{
        // Try to get users list - this requires users:read
        _, err := c.api.GetUsers()

        if err != nil &amp;&amp; strings.Contains(err.Error(), "missing_scope") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func (c *Client) GetChannelInfo(channelID string) (*Channel, error) <span class="cov8" title="1">{
        // This is used for permission testing in health checks
        // We'll just return a mock error for permission testing
        return nil, fmt.Errorf("channel_not_found")
}</span>

// ResolveChannelNameToID converts a channel name (like "#general" or "general") to its Slack channel ID.
func (c *Client) ResolveChannelNameToID(channelName string) (string, error) <span class="cov8" title="1">{
        // Clean the channel name
        cleanName := strings.TrimPrefix(channelName, "#")

        // Rate limit before API call
        ctx, cancel := context.WithTimeout(context.Background(), time.Minute*2)
        defer cancel()

        if err := c.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("rate limiter cancelled: %w", err)
        }</span>

        // Get all channels to find the matching one
        <span class="cov8" title="1">params := &amp;slack.GetConversationsParameters{
                Types: []string{"public_channel", "private_channel"},
                Limit: 1000,
        }

        channels, _, err := c.api.GetConversations(params)
        if err != nil </span><span class="cov0" title="0">{
                c.rateLimiter.OnRateLimitError()
                return "", fmt.Errorf("failed to get channels: %w", err)
        }</span>

        // Mark successful API call
        <span class="cov8" title="1">c.rateLimiter.OnSuccess()

        // Find channel by name
        for _, channel := range channels </span><span class="cov8" title="1">{
                if channel.Name == cleanName </span><span class="cov8" title="1">{
                        return channel.ID, nil
                }</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("channel '%s' not found", channelName)</span>
}

func (c *Client) GetInactiveChannels(warnSeconds int, archiveSeconds int) (toWarn []Channel, toArchive []Channel, err error) <span class="cov8" title="1">{
        logger.WithFields(logger.LogFields{
                "warn_seconds":    warnSeconds,
                "archive_seconds": archiveSeconds,
        }).Debug("Starting inactive channel detection")

        // Calculate cutoff times
        warnCutoff := time.Now().Add(-time.Duration(warnSeconds) * time.Second)

        // Get all channels
        ctx, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        if err := c.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("rate limiter cancelled: %w", err)
        }</span>

        <span class="cov8" title="1">allChannels, _, err := c.api.GetConversations(&amp;slack.GetConversationsParameters{
                Types:           []string{"public_channel", "private_channel"},
                Limit:           1000,
                ExcludeArchived: true,
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("failed to get conversations: %w", err)
        }</span>

        <span class="cov8" title="1">c.rateLimiter.OnSuccess()

        logger.WithField("total_channels", len(allChannels)).Debug("Retrieved channels for activity analysis")

        // Pre-filter channels using metadata to reduce API calls
        var candidateChannels []slack.Channel
        var skippedNew, skippedExcluded, skippedActive int

        for _, ch := range allChannels </span><span class="cov8" title="1">{
                // Skip if channel is too new to possibly need warning
                // If a channel was created after the warn cutoff, it can't be inactive long enough to warn
                created := time.Unix(int64(ch.Created), 0)
                if created.After(warnCutoff) </span><span class="cov8" title="1">{
                        logger.WithFields(logger.LogFields{
                                "channel":     ch.Name,
                                "created":     created.Format("2006-01-02 15:04:05"),
                                "warn_cutoff": warnCutoff.Format("2006-01-02 15:04:05"),
                        }).Debug("Skipping channel: created after warn cutoff")
                        skippedNew++
                        continue</span>
                }

                // Skip channels with certain patterns (configurable exclusions)
                <span class="cov8" title="1">if c.shouldSkipChannel(ch.Name) </span><span class="cov8" title="1">{
                        logger.WithField("channel", ch.Name).Debug("Skipping excluded channel")
                        skippedExcluded++
                        continue</span>
                }

                // Use metadata to pre-filter potentially inactive channels
                <span class="cov8" title="1">if c.seemsActiveFromMetadata(ch, warnCutoff) </span><span class="cov0" title="0">{
                        logger.WithFields(logger.LogFields{
                                "channel": ch.Name,
                                "reason":  "metadata_shows_recent_activity",
                        }).Debug("Channel seems active from metadata, skipping message history check")
                        skippedActive++
                        continue</span>
                }

                <span class="cov8" title="1">candidateChannels = append(candidateChannels, ch)</span>
        }

        <span class="cov8" title="1">logger.WithFields(logger.LogFields{
                "total_channels":     len(allChannels),
                "candidate_channels": len(candidateChannels),
                "skipped_new":        skippedNew,
                "skipped_excluded":   skippedExcluded,
                "skipped_active":     skippedActive,
        }).Info("Pre-filtered channels using metadata")

        // Auto-join all public candidate channels before analyzing them
        // This is critical for getting accurate message history data
        joinedCount, err := c.autoJoinPublicChannels(candidateChannels)
        if err != nil </span><span class="cov0" title="0">{
                return toWarn, toArchive, fmt.Errorf("failed to auto-join channels - inactive detection requires channel membership: %w", err)
        }</span>
        <span class="cov8" title="1">logger.WithField("joined_count", joinedCount).Info("Auto-joined public channels")

        // Now check message history only for candidate channels
        for _, ch := range candidateChannels </span><span class="cov8" title="1">{
                logger.WithField("channel", ch.Name).Debug("Checking message history for candidate channel")

                // Get channel activity with retry for rate limits
                lastActivity, hasWarning, warningTime, err := c.getChannelActivityWithRetry(ch.ID, ch.Name)
                if err != nil </span><span class="cov0" title="0">{
                        errStr := err.Error()

                        // Handle different error types with appropriate policies
                        if strings.Contains(errStr, "rate_limited") || strings.Contains(errStr, "rate limit") </span><span class="cov0" title="0">{
                                logger.WithFields(logger.LogFields{
                                        "channel": ch.Name,
                                        "error":   errStr,
                                }).Warn("Rate limited by Slack API - this affects all subsequent requests, stopping analysis")
                                return toWarn, toArchive, fmt.Errorf("rate limited by Slack API while processing channel %s: %w", ch.Name, err)
                        }</span>

                        <span class="cov0" title="0">if strings.Contains(errStr, "not_in_channel") </span><span class="cov0" title="0">{
                                // Bot isn't in channel, treat as potentially inactive
                                logger.WithFields(logger.LogFields{
                                        "channel": ch.Name,
                                }).Debug("Bot not in channel, treating as potentially inactive")
                                lastActivity = time.Unix(0, 0) // Very old timestamp
                                hasWarning = false
                                warningTime = time.Time{}
                        }</span> else<span class="cov0" title="0"> {
                                // For other errors, skip the channel to be safe
                                logger.WithFields(logger.LogFields{
                                        "channel": ch.Name,
                                        "error":   errStr,
                                }).Warn("Failed to get channel activity, skipping")
                                continue</span>
                        }
                }

                <span class="cov8" title="1">logger.WithFields(logger.LogFields{
                        "channel":       ch.Name,
                        "last_activity": lastActivity.Format("2006-01-02 15:04:05"),
                        "has_warning":   hasWarning,
                        "warning_time":  warningTime.Format("2006-01-02 15:04:05"),
                }).Debug("Retrieved channel activity data")

                created := time.Unix(int64(ch.Created), 0)
                channel := Channel{
                        ID:           ch.ID,
                        Name:         ch.Name,
                        Created:      created,
                        Purpose:      ch.Purpose.Value,
                        Creator:      ch.Creator,
                        LastActivity: lastActivity,
                        MemberCount:  ch.NumMembers,
                        IsArchived:   ch.IsArchived,
                }

                // Decision logic
                if hasWarning </span><span class="cov8" title="1">{
                        // Channel was already warned, check if it should be archived
                        // Archive if: last activity was before warning AND warning was sent long enough ago
                        gracePeriodExpired := time.Since(warningTime) &gt; time.Duration(archiveSeconds)*time.Second
                        if lastActivity.Before(warningTime) &amp;&amp; gracePeriodExpired </span><span class="cov8" title="1">{
                                toArchive = append(toArchive, channel)
                                logger.WithFields(logger.LogFields{
                                        "channel":       ch.Name,
                                        "last_activity": lastActivity.Format("2006-01-02 15:04:05"),
                                        "warning_time":  warningTime.Format("2006-01-02 15:04:05"),
                                }).Debug("Channel marked for archival")
                        }</span>
                } else<span class="cov8" title="1"> {
                        // No warning yet, check if it should be warned
                        if lastActivity.IsZero() || lastActivity.Before(warnCutoff) </span><span class="cov8" title="1">{
                                toWarn = append(toWarn, channel)
                                logger.WithFields(logger.LogFields{
                                        "channel":       ch.Name,
                                        "last_activity": lastActivity.Format("2006-01-02 15:04:05"),
                                }).Debug("Channel marked for warning")
                        }</span>
                }
        }

        <span class="cov8" title="1">logger.WithFields(logger.LogFields{
                "to_warn":    len(toWarn),
                "to_archive": len(toArchive),
        }).Info("Inactive channel analysis completed")

        return toWarn, toArchive, nil</span>
}

// GetInactiveChannelsWithDetails returns inactive channels with detailed message information and user name resolution
func (c *Client) GetInactiveChannelsWithDetails(warnSeconds int, archiveSeconds int, userMap map[string]string) (toWarn []Channel, toArchive []Channel, err error) <span class="cov8" title="1">{
        logger.WithFields(logger.LogFields{
                "warn_seconds":    warnSeconds,
                "archive_seconds": archiveSeconds,
        }).Debug("Starting inactive channel detection with message details")

        // Calculate cutoff times
        warnCutoff := time.Now().Add(-time.Duration(warnSeconds) * time.Second)

        // Get all channels
        ctx, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        if err := c.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("rate limiter cancelled: %w", err)
        }</span>

        <span class="cov8" title="1">allChannels, _, err := c.api.GetConversations(&amp;slack.GetConversationsParameters{
                Types:           []string{"public_channel", "private_channel"},
                Limit:           1000,
                ExcludeArchived: true,
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("failed to get conversations: %w", err)
        }</span>

        <span class="cov8" title="1">c.rateLimiter.OnSuccess()

        logger.WithField("total_channels", len(allChannels)).Debug("Retrieved channels for detailed activity analysis")

        // Pre-filter channels using metadata to reduce API calls
        var candidateChannels []slack.Channel
        var skippedActive, skippedExcluded, skippedNew int

        for _, ch := range allChannels </span><span class="cov8" title="1">{
                // Skip excluded channels
                if c.shouldSkipChannel(ch.Name) </span><span class="cov0" title="0">{
                        skippedExcluded++
                        continue</span>
                }

                // Skip channels that are too new to possibly need warnings
                <span class="cov8" title="1">created := time.Unix(int64(ch.Created), 0)
                if created.After(warnCutoff) </span><span class="cov0" title="0">{
                        skippedNew++
                        continue</span>
                }

                // Skip channels that seem active from metadata
                <span class="cov8" title="1">if c.seemsActiveFromMetadata(ch, warnCutoff) </span><span class="cov0" title="0">{
                        skippedActive++
                        continue</span>
                }

                <span class="cov8" title="1">candidateChannels = append(candidateChannels, ch)</span>
        }

        <span class="cov8" title="1">logger.WithFields(logger.LogFields{
                "total_channels":     len(allChannels),
                "candidate_channels": len(candidateChannels),
                "skipped_active":     skippedActive,
                "skipped_excluded":   skippedExcluded,
                "skipped_new":        skippedNew,
        }).Info("Pre-filtered channels using metadata")

        fmt.Printf("📞 API Call 2: Getting channel list with metadata...\n")
        fmt.Printf("✅ Got %d channels from API\n", len(allChannels))
        fmt.Printf("   Pre-filtered to %d candidates (skipped %d active, %d excluded, %d too new)\n\n",
                len(candidateChannels), skippedActive, skippedExcluded, skippedNew)

        // Auto-join public channels before analysis
        fmt.Printf("📞 API Calls 3+: Auto-joining public channels for accurate analysis...\n")
        joinedCount, err := c.autoJoinPublicChannels(candidateChannels)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to auto-join channels - inactive detection requires channel membership: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("✅ Auto-joined %d channels\n\n", joinedCount)

        logger.WithField("joined_count", joinedCount).Info("Auto-joined public channels")

        // Now analyze each candidate channel for activity with detailed reporting
        now := time.Now()
        for _, ch := range candidateChannels </span><span class="cov8" title="1">{

                lastActivity, hasWarning, warningTime, lastMessage, err := c.GetChannelActivityWithMessageAndUsers(ch.ID, userMap)
                if err != nil </span><span class="cov0" title="0">{
                        errStr := err.Error()
                        // Log the error but continue with other channels
                        logger.WithFields(logger.LogFields{
                                "channel": ch.Name,
                                "error":   errStr,
                        }).Error("Failed to get channel activity")

                        // If rate limited, stop processing entirely
                        if strings.Contains(errStr, "rate_limited") || strings.Contains(errStr, "rate limit") </span><span class="cov0" title="0">{
                                logger.WithFields(logger.LogFields{
                                        "channel": ch.Name,
                                        "error":   errStr,
                                }).Warn("Rate limited by Slack API - this affects all subsequent requests, stopping analysis")

                                fmt.Printf("❌ API Call failed: Rate limited while checking #%s\n", ch.Name)
                                return toWarn, toArchive, fmt.Errorf("rate limited by Slack API")
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("❌ API Call failed: Error checking #%s: %s\n", ch.Name, errStr)
                        continue</span>
                }

                <span class="cov8" title="1">fmt.Printf("✅ API Call succeeded\n")

                // Create enhanced channel with message details
                enhancedChannel := Channel{
                        ID:           ch.ID,
                        Name:         ch.Name,
                        Created:      time.Unix(int64(ch.Created), 0),
                        Purpose:      ch.Purpose.Value,
                        Creator:      ch.Creator,
                        LastActivity: lastActivity,
                        MemberCount:  ch.NumMembers,
                        IsArchived:   ch.IsArchived,
                        LastMessage:  lastMessage,
                }

                // Show detailed info about the channel
                var activityStr string
                if lastActivity.IsZero() </span><span class="cov0" title="0">{
                        created := time.Unix(int64(ch.Created), 0)
                        createdDuration := now.Sub(created)
                        activityStr = fmt.Sprintf("no real messages (created %s ago)", formatDuration(createdDuration))
                }</span> else<span class="cov8" title="1"> {
                        duration := now.Sub(lastActivity)
                        activityStr = fmt.Sprintf("last real message %s ago", formatDuration(duration))
                        if hasWarning &amp;&amp; !warningTime.IsZero() </span><span class="cov0" title="0">{
                                warningDuration := now.Sub(warningTime)
                                activityStr += fmt.Sprintf(" (warning sent %s ago)", formatDuration(warningDuration))
                        }</span>
                }

                <span class="cov8" title="1">fmt.Printf("  #%-20s - %s\n", ch.Name, activityStr)

                // Show message details if available
                if lastMessage != nil </span><span class="cov8" title="1">{
                        // Truncate long messages
                        messageText := lastMessage.Text
                        if len(messageText) &gt; 80 </span><span class="cov0" title="0">{
                                messageText = messageText[:77] + "..."
                        }</span>

                        // Replace newlines with spaces for cleaner display
                        <span class="cov8" title="1">messageText = strings.ReplaceAll(messageText, "\n", " ")

                        botIndicator := ""
                        if lastMessage.IsBot </span><span class="cov0" title="0">{
                                botIndicator = " (bot)"
                        }</span>

                        // Use resolved name if available, fallback to ID
                        <span class="cov8" title="1">authorName := lastMessage.UserName
                        if authorName == "" </span><span class="cov0" title="0">{
                                authorName = lastMessage.User
                        }</span>

                        <span class="cov8" title="1">fmt.Printf("    └─ Author: %s%s | Message: \"%s\"\n", authorName, botIndicator, messageText)</span>
                }
                <span class="cov8" title="1">fmt.Println() // Empty line between channels

                // Determine if this channel needs warning or archiving
                if hasWarning </span><span class="cov0" title="0">{
                        // Channel already has a warning, check if grace period has expired
                        // Archive if warning was sent more than archiveSeconds ago
                        gracePeriodExpired := time.Since(warningTime) &gt; time.Duration(archiveSeconds)*time.Second
                        if gracePeriodExpired </span><span class="cov0" title="0">{
                                toArchive = append(toArchive, enhancedChannel)
                                logger.WithFields(logger.LogFields{
                                        "channel":      ch.Name,
                                        "warning_time": warningTime.Format("2006-01-02 15:04:05"),
                                        "grace_period": "expired",
                                }).Debug("Channel marked for archival - grace period expired")
                        }</span>
                } else<span class="cov8" title="1"> if lastActivity.IsZero() || lastActivity.Before(warnCutoff) </span><span class="cov8" title="1">{
                        // Channel has no messages or is inactive and hasn't been warned yet
                        toWarn = append(toWarn, enhancedChannel)
                        logger.WithFields(logger.LogFields{
                                "channel":       ch.Name,
                                "last_activity": lastActivity.Format("2006-01-02 15:04:05"),
                                "inactive_for":  now.Sub(lastActivity).String(),
                        }).Debug("Channel marked for warning")
                }</span>
        }

        <span class="cov8" title="1">logger.WithFields(logger.LogFields{
                "channels_to_warn":    len(toWarn),
                "channels_to_archive": len(toArchive),
        }).Info("Inactive channel analysis completed")

        return toWarn, toArchive, nil</span>
}

// GetInactiveChannelsWithDetailsAndExclusions returns inactive channels with exclusion support
func (c *Client) GetInactiveChannelsWithDetailsAndExclusions(warnSeconds int, archiveSeconds int, userMap map[string]string, excludeChannels, excludePrefixes []string) (toWarn []Channel, toArchive []Channel, err error) <span class="cov8" title="1">{
        logger.WithFields(logger.LogFields{
                "warn_seconds":     warnSeconds,
                "archive_seconds":  archiveSeconds,
                "exclude_channels": excludeChannels,
                "exclude_prefixes": excludePrefixes,
        }).Debug("Starting inactive channel detection with message details and exclusions")

        // Calculate cutoff times
        warnCutoff := time.Now().Add(-time.Duration(warnSeconds) * time.Second)

        // Get all channels
        ctx, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        if err := c.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("rate limiter cancelled: %w", err)
        }</span>

        <span class="cov8" title="1">allChannels, _, err := c.api.GetConversations(&amp;slack.GetConversationsParameters{
                Types:           []string{"public_channel", "private_channel"},
                Limit:           1000,
                ExcludeArchived: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get conversations: %w", err)
        }</span>

        <span class="cov8" title="1">c.rateLimiter.OnSuccess()

        logger.WithField("total_channels", len(allChannels)).Debug("Retrieved channels for detailed activity analysis")

        // Pre-filter channels using metadata and exclusions to reduce API calls
        var candidateChannels []slack.Channel
        var skippedActive, skippedExcluded, skippedNew, skippedUserExcluded int

        for _, ch := range allChannels </span><span class="cov8" title="1">{
                // Check user-specified exclusions first
                if c.shouldSkipChannelWithExclusions(ch.Name, excludeChannels, excludePrefixes) </span><span class="cov8" title="1">{
                        skippedUserExcluded++
                        continue</span>
                }

                // Skip default excluded channels
                <span class="cov8" title="1">if c.shouldSkipChannel(ch.Name) </span><span class="cov0" title="0">{
                        skippedExcluded++
                        continue</span>
                }

                // Skip channels that are too new to possibly need warnings
                <span class="cov8" title="1">created := time.Unix(int64(ch.Created), 0)
                if created.After(warnCutoff) </span><span class="cov0" title="0">{
                        skippedNew++
                        continue</span>
                }

                // Skip channels that seem active from metadata
                <span class="cov8" title="1">if c.seemsActiveFromMetadata(ch, warnCutoff) </span><span class="cov0" title="0">{
                        skippedActive++
                        continue</span>
                }

                <span class="cov8" title="1">candidateChannels = append(candidateChannels, ch)</span>
        }

        <span class="cov8" title="1">logger.WithFields(logger.LogFields{
                "total_channels":        len(allChannels),
                "candidate_channels":    len(candidateChannels),
                "skipped_active":        skippedActive,
                "skipped_excluded":      skippedExcluded,
                "skipped_new":           skippedNew,
                "skipped_user_excluded": skippedUserExcluded,
        }).Info("Pre-filtered channels using metadata and exclusions")

        fmt.Printf("📞 API Call 2: Getting channel list with metadata...\n")
        fmt.Printf("✅ Got %d channels from API\n", len(allChannels))
        fmt.Printf("   Pre-filtered to %d candidates (skipped %d active, %d excluded, %d too new, %d user-excluded)\n\n",
                len(candidateChannels), skippedActive, skippedExcluded, skippedNew, skippedUserExcluded)

        // Auto-join public channels before analysis
        fmt.Printf("📞 API Calls 3+: Auto-joining public channels for accurate analysis...\n")
        joinedCount, err := c.autoJoinPublicChannels(candidateChannels)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to auto-join channels - inactive detection requires channel membership: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("✅ Auto-joined %d channels\n\n", joinedCount)

        logger.WithField("joined_count", joinedCount).Info("Auto-joined public channels")

        // Now analyze each candidate channel for activity with detailed reporting
        now := time.Now()
        for _, ch := range candidateChannels </span><span class="cov8" title="1">{

                lastActivity, hasWarning, warningTime, lastMessage, err := c.GetChannelActivityWithMessageAndUsers(ch.ID, userMap)
                if err != nil </span><span class="cov0" title="0">{
                        errStr := err.Error()
                        // Log the error but continue with other channels
                        logger.WithFields(logger.LogFields{
                                "channel": ch.Name,
                                "error":   errStr,
                        }).Error("Failed to get channel activity")

                        // If rate limited, stop processing entirely
                        if strings.Contains(errStr, "rate_limited") || strings.Contains(errStr, "rate limit") </span><span class="cov0" title="0">{
                                logger.WithFields(logger.LogFields{
                                        "channel": ch.Name,
                                        "error":   errStr,
                                }).Warn("Rate limited by Slack API - this affects all subsequent requests, stopping analysis")

                                fmt.Printf("❌ API Call failed: Rate limited while checking #%s\n", ch.Name)
                                return toWarn, toArchive, fmt.Errorf("rate limited by Slack API")
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("❌ API Call failed: Error checking #%s: %s\n", ch.Name, errStr)
                        continue</span>
                }

                <span class="cov8" title="1">fmt.Printf("✅ API Call succeeded\n")

                // Create enhanced channel with message details
                enhancedChannel := Channel{
                        ID:           ch.ID,
                        Name:         ch.Name,
                        Created:      time.Unix(int64(ch.Created), 0),
                        Purpose:      ch.Purpose.Value,
                        Creator:      ch.Creator,
                        LastActivity: lastActivity,
                        MemberCount:  ch.NumMembers,
                        IsArchived:   ch.IsArchived,
                        LastMessage:  lastMessage,
                }

                // Show detailed info about the channel
                var activityStr string
                if lastActivity.IsZero() </span><span class="cov0" title="0">{
                        created := time.Unix(int64(ch.Created), 0)
                        createdDuration := now.Sub(created)
                        activityStr = fmt.Sprintf("no real messages (created %s ago)", formatDuration(createdDuration))
                }</span> else<span class="cov8" title="1"> {
                        duration := now.Sub(lastActivity)
                        activityStr = fmt.Sprintf("last real message %s ago", formatDuration(duration))
                        if hasWarning &amp;&amp; !warningTime.IsZero() </span><span class="cov0" title="0">{
                                warningDuration := now.Sub(warningTime)
                                activityStr += fmt.Sprintf(" (warning sent %s ago)", formatDuration(warningDuration))
                        }</span>
                }

                <span class="cov8" title="1">fmt.Printf("  #%-20s - %s\n", ch.Name, activityStr)

                // Show message details if available
                if lastMessage != nil </span><span class="cov8" title="1">{
                        // Truncate long messages
                        messageText := lastMessage.Text
                        if len(messageText) &gt; 80 </span><span class="cov0" title="0">{
                                messageText = messageText[:77] + "..."
                        }</span>

                        // Replace newlines with spaces for cleaner display
                        <span class="cov8" title="1">messageText = strings.ReplaceAll(messageText, "\n", " ")

                        botIndicator := ""
                        if lastMessage.IsBot </span><span class="cov0" title="0">{
                                botIndicator = " (bot)"
                        }</span>

                        // Use resolved name if available, fallback to ID
                        <span class="cov8" title="1">authorName := lastMessage.UserName
                        if authorName == "" </span><span class="cov0" title="0">{
                                authorName = lastMessage.User
                        }</span>

                        <span class="cov8" title="1">fmt.Printf("    └─ Author: %s%s | Message: \"%s\"\n", authorName, botIndicator, messageText)</span>
                }
                <span class="cov8" title="1">fmt.Println() // Empty line between channels

                // Determine if this channel needs warning or archiving
                if hasWarning </span><span class="cov0" title="0">{
                        // Channel already has a warning, check if grace period has expired
                        // Archive if warning was sent more than archiveSeconds ago
                        gracePeriodExpired := time.Since(warningTime) &gt; time.Duration(archiveSeconds)*time.Second
                        if gracePeriodExpired </span><span class="cov0" title="0">{
                                toArchive = append(toArchive, enhancedChannel)
                                logger.WithFields(logger.LogFields{
                                        "channel":      ch.Name,
                                        "warning_time": warningTime.Format("2006-01-02 15:04:05"),
                                        "grace_period": "expired",
                                }).Debug("Channel marked for archival - grace period expired")
                        }</span>
                } else<span class="cov8" title="1"> if lastActivity.IsZero() || lastActivity.Before(warnCutoff) </span><span class="cov8" title="1">{
                        // Channel has no messages or is inactive and hasn't been warned yet
                        toWarn = append(toWarn, enhancedChannel)
                        logger.WithFields(logger.LogFields{
                                "channel":       ch.Name,
                                "last_activity": lastActivity.Format("2006-01-02 15:04:05"),
                                "inactive_for":  now.Sub(lastActivity).String(),
                        }).Debug("Channel marked for warning")
                }</span>
        }

        <span class="cov8" title="1">logger.WithFields(logger.LogFields{
                "channels_to_warn":    len(toWarn),
                "channels_to_archive": len(toArchive),
        }).Info("Inactive channel analysis completed")

        return toWarn, toArchive, nil</span>
}

// shouldSkipChannelWithExclusions checks if a channel should be skipped based on user exclusions
func (c *Client) shouldSkipChannelWithExclusions(channelName string, excludeChannels, excludePrefixes []string) bool <span class="cov8" title="1">{
        // Check exact channel name matches
        for _, excluded := range excludeChannels </span><span class="cov8" title="1">{
                if channelName == excluded </span><span class="cov8" title="1">{
                        logger.WithFields(logger.LogFields{
                                "channel": channelName,
                                "reason":  "exact_match",
                                "exclude": excluded,
                        }).Debug("Skipping channel due to user exclusion")
                        return true
                }</span>
        }

        // Check prefix matches
        <span class="cov8" title="1">for _, prefix := range excludePrefixes </span><span class="cov8" title="1">{
                if strings.HasPrefix(channelName, prefix) </span><span class="cov8" title="1">{
                        logger.WithFields(logger.LogFields{
                                "channel": channelName,
                                "reason":  "prefix_match",
                                "prefix":  prefix,
                        }).Debug("Skipping channel due to user prefix exclusion")
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// formatDuration formats a duration in a human-readable way
func formatDuration(d time.Duration) string <span class="cov8" title="1">{
        if d &lt; time.Minute </span><span class="cov8" title="1">{
                seconds := int(d.Seconds())
                if seconds == 1 </span><span class="cov8" title="1">{
                        return "1 second"
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%d seconds", seconds)</span>
        }

        <span class="cov8" title="1">if d &lt; time.Hour </span><span class="cov8" title="1">{
                minutes := int(d.Minutes())
                if minutes == 1 </span><span class="cov8" title="1">{
                        return oneMinuteText
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%d minutes", minutes)</span>
        }

        <span class="cov8" title="1">if d &lt; 24*time.Hour </span><span class="cov8" title="1">{
                hours := int(d.Hours())
                if hours == 1 </span><span class="cov8" title="1">{
                        return oneHourText
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d hours", hours)</span>
        }

        <span class="cov8" title="1">days := int(d.Hours() / 24)
        if days == 1 </span><span class="cov8" title="1">{
                return oneDayText
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%d days", days)</span>
}

func (c *Client) getChannelActivityWithRetry(channelID, channelName string) (lastActivity time.Time, hasWarning bool, warningTime time.Time, err error) <span class="cov8" title="1">{
        // Just call the base function - rate limiting should be handled globally
        // If we get rate limited, that affects the entire API, so we should stop processing
        return c.getChannelActivity(channelID)
}</span>

func (c *Client) getChannelActivity(channelID string) (lastActivity time.Time, hasWarning bool, warningTime time.Time, err error) <span class="cov8" title="1">{
        const maxRetries = 3
        var history *slack.GetConversationHistoryResponse

        for attempt := 1; attempt &lt;= maxRetries; attempt++ </span><span class="cov8" title="1">{
                // Rate limit before API call
                ctx, cancel := context.WithTimeout(context.Background(), time.Minute*2)

                if err := c.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                        cancel()
                        return time.Time{}, false, time.Time{}, fmt.Errorf("rate limiter cancelled: %w", err)
                }</span>
                <span class="cov8" title="1">cancel()

                // Optimized two-stage approach:
                // 1. Get just the last message to check if channel is obviously active
                // 2. Only if needed, get more messages to check for bot warnings

                // Stage 1: Get recent messages to find the most recent real one
                params := &amp;slack.GetConversationHistoryParameters{
                        ChannelID: channelID,
                        Limit:     10, // Get enough messages to find real ones past any system messages
                }

                history, err = c.api.GetConversationHistory(params)
                if err != nil </span><span class="cov8" title="1">{
                        errStr := err.Error()

                        // Handle rate limiting with retry
                        if strings.Contains(errStr, "rate_limited") || strings.Contains(errStr, "rate limit") </span><span class="cov0" title="0">{


                                // If not the last attempt, continue to retry
                                if attempt &lt; maxRetries </span><span class="cov0" title="0">{
                                        // Parse Slack's retry-after directive
                                        waitDuration := parseSlackRetryAfter(errStr)
                                        if waitDuration &gt; 0 </span><span class="cov0" title="0">{
                                                // Wait for the specified duration quietly without verbose output
                                                showProgressBar(waitDuration)
                                        }</span> else<span class="cov0" title="0"> {
                                                // Fallback to our rate limiter if we can't parse Slack's directive
                                                c.rateLimiter.OnRateLimitError()
                                                // Use fallback backoff quietly without verbose output
                                        }</span>
                                        <span class="cov0" title="0">continue</span>
                                }
                                // Last attempt failed, return error
                                // All retry attempts failed, proceeding to return error
                                <span class="cov0" title="0">return time.Time{}, false, time.Time{}, fmt.Errorf("failed to get channel history after %d attempts, final Slack error: %s", maxRetries, errStr)</span>
                        }

                        // Non-rate-limit errors - don't retry
                        <span class="cov8" title="1">return time.Time{}, false, time.Time{}, fmt.Errorf("failed to get channel history: %w", err)</span>
                }

                // Success - break out of retry loop
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">c.rateLimiter.OnSuccess()

        if len(history.Messages) == 0 </span><span class="cov8" title="1">{
                // No messages
                return time.Unix(0, 0), false, time.Time{}, nil
        }</span>

        // Find the most recent "real" message (not join/leave/system messages)
        <span class="cov8" title="1">botUserID := c.getBotUserID()
        var lastRealMsg *slack.Message
        var lastRealMsgTime time.Time

        for _, msg := range history.Messages </span><span class="cov8" title="1">{
                if isRealMessage(msg, botUserID) </span><span class="cov8" title="1">{
                        lastRealMsg = &amp;msg
                        if msgTime, err := parseSlackTimestamp(msg.Timestamp); err == nil </span><span class="cov8" title="1">{
                                lastRealMsgTime = msgTime
                        }</span>
                        <span class="cov8" title="1">break</span> // Found the most recent real message
                }
        }

        // If no real messages found in the first message, get more history
        <span class="cov8" title="1">if lastRealMsg == nil </span><span class="cov8" title="1">{
                return c.getDetailedChannelActivity(channelID, botUserID)
        }</span>

        // If the last real message is from the bot and contains a warning, we need more context
        <span class="cov8" title="1">if lastRealMsg.User == botUserID &amp;&amp; strings.Contains(lastRealMsg.Text, "inactive channel warning") </span><span class="cov8" title="1">{
                // Stage 2: Get more messages to find actual user activity and warning history
                return c.getDetailedChannelActivity(channelID, botUserID)
        }</span>

        // If the last real message is from a user, that's our activity time
        <span class="cov8" title="1">if lastRealMsg.User != botUserID </span><span class="cov8" title="1">{
                return lastRealMsgTime, false, time.Time{}, nil
        }</span>

        // If the last real message is from the bot but not a warning, we need to look deeper
        // to find the last user activity
        <span class="cov0" title="0">return c.getDetailedChannelActivity(channelID, botUserID)</span>
}

func (c *Client) getDetailedChannelActivity(channelID, botUserID string) (lastActivity time.Time, hasWarning bool, warningTime time.Time, err error) <span class="cov8" title="1">{
        const maxRetries = 3
        var history *slack.GetConversationHistoryResponse

        for attempt := 1; attempt &lt;= maxRetries; attempt++ </span><span class="cov8" title="1">{
                // Rate limit before API call
                ctx, cancel := context.WithTimeout(context.Background(), time.Minute*2)

                if err := c.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                        cancel()
                        return time.Time{}, false, time.Time{}, fmt.Errorf("rate limiter cancelled: %w", err)
                }</span>
                <span class="cov8" title="1">cancel()

                // Get more messages to analyze warning history and find user activity
                params := &amp;slack.GetConversationHistoryParameters{
                        ChannelID: channelID,
                        Limit:     50, // Reasonable limit to find warnings and user activity
                }

                history, err = c.api.GetConversationHistory(params)
                if err != nil </span><span class="cov0" title="0">{
                        errStr := err.Error()

                        // Handle rate limiting with retry
                        if strings.Contains(errStr, "rate_limited") || strings.Contains(errStr, "rate limit") </span><span class="cov0" title="0">{
                                logger.WithFields(logger.LogFields{
                                        "attempt":     attempt,
                                        "max_tries":   maxRetries,
                                        "channel":     channelID,
                                        "slack_error": errStr,
                                }).Warn("Rate limited on detailed history, will retry after Slack-specified delay")

                                // Print to stdout so user can see retry attempts
                                fmt.Printf("   🔄 Detailed history retry %d/%d for channel %s (Slack error: %s)\n", attempt, maxRetries, channelID, errStr)

                                // If not the last attempt, continue to retry
                                if attempt &lt; maxRetries </span><span class="cov0" title="0">{
                                        // Parse Slack's retry-after directive
                                        waitDuration := parseSlackRetryAfter(errStr)
                                        if waitDuration &gt; 0 </span><span class="cov0" title="0">{
                                                fmt.Printf("   ⏳ Slack says wait %s (includes 3s buffer) before detailed retry...\n", waitDuration)
                                                time.Sleep(waitDuration)
                                        }</span> else<span class="cov0" title="0"> {
                                                // Fallback to our rate limiter if we can't parse Slack's directive
                                                c.rateLimiter.OnRateLimitError()
                                                fmt.Printf("   ⏳ Using fallback backoff before detailed retry...\n")
                                        }</span>
                                        <span class="cov0" title="0">continue</span>
                                }
                                // Last attempt failed, return error
                                <span class="cov0" title="0">fmt.Printf("   ❌ All %d detailed retry attempts failed\n", maxRetries)
                                return time.Time{}, false, time.Time{}, fmt.Errorf("failed to get detailed channel history after %d attempts, final Slack error: %s", maxRetries, errStr)</span>
                        }

                        // Non-rate-limit errors - don't retry
                        <span class="cov0" title="0">return time.Time{}, false, time.Time{}, fmt.Errorf("failed to get detailed channel history: %w", err)</span>
                }

                // Success - break out of retry loop
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">c.rateLimiter.OnSuccess()

        if len(history.Messages) == 0 </span><span class="cov0" title="0">{
                return time.Unix(0, 0), false, time.Time{}, nil
        }</span>

        // Find the most recent real user message and check for warnings
        <span class="cov8" title="1">mostRecentActivity := time.Time{}
        hasWarningMessage := false
        mostRecentWarning := time.Time{}

        for _, msg := range history.Messages </span><span class="cov8" title="1">{
                msgTime, err := parseSlackTimestamp(msg.Timestamp)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if this is a warning message from our bot
                <span class="cov8" title="1">if msg.User == botUserID &amp;&amp; strings.Contains(msg.Text, "inactive channel warning") </span><span class="cov8" title="1">{
                        hasWarningMessage = true
                        if msgTime.After(mostRecentWarning) </span><span class="cov8" title="1">{
                                mostRecentWarning = msgTime
                        }</span>
                }

                // Track most recent real user activity (excluding system messages)
                <span class="cov8" title="1">if msg.User != botUserID &amp;&amp; isRealMessage(msg, botUserID) &amp;&amp; msgTime.After(mostRecentActivity) </span><span class="cov8" title="1">{
                        mostRecentActivity = msgTime
                }</span>
        }

        // If only bot messages exist, use the oldest message time
        <span class="cov8" title="1">if mostRecentActivity.IsZero() &amp;&amp; len(history.Messages) &gt; 0 </span><span class="cov8" title="1">{
                if msgTime, err := parseSlackTimestamp(history.Messages[len(history.Messages)-1].Timestamp); err == nil </span><span class="cov8" title="1">{
                        mostRecentActivity = msgTime
                }</span>
        }

        <span class="cov8" title="1">return mostRecentActivity, hasWarningMessage, mostRecentWarning, nil</span>
}

func (c *Client) autoJoinPublicChannels(channels []slack.Channel) (int, error) <span class="cov8" title="1">{
        joinedCount := 0
        var fatalErrors []string
        var skippedCount = 0

        for _, ch := range channels </span><span class="cov8" title="1">{
                // Only join public channels
                if ch.IsPrivate </span><span class="cov8" title="1">{
                        logger.WithField("channel", ch.Name).Debug("Skipping private channel for auto-join")
                        skippedCount++
                        continue</span>
                }

                // Rate limit before joining
                <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), time.Second*10)
                if err := c.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                        cancel()
                        return joinedCount, fmt.Errorf("rate limiter cancelled during auto-join: %w", err)
                }</span>
                <span class="cov8" title="1">cancel()

                // Try to join the channel
                _, _, _, err := c.api.JoinConversation(ch.ID)
                if err != nil </span><span class="cov8" title="1">{
                        errStr := err.Error()

                        // Handle rate limiting - this is fatal
                        if strings.Contains(errStr, "rate_limited") </span><span class="cov8" title="1">{
                                c.rateLimiter.OnRateLimitError()
                                return joinedCount, fmt.Errorf("rate limited during auto-join: %w", err)
                        }</span>

                        // Already in channel is success
                        <span class="cov8" title="1">if strings.Contains(errStr, "already_in_channel") </span><span class="cov8" title="1">{
                                logger.WithField("channel", ch.Name).Debug("Already in channel")
                                c.rateLimiter.OnSuccess()
                                joinedCount++
                                continue</span>
                        }

                        // These indicate the channel can't be joined, but that's OK to skip
                        <span class="cov8" title="1">if strings.Contains(errStr, "is_archived") </span><span class="cov8" title="1">{
                                logger.WithField("channel", ch.Name).Debug("Channel is archived, skipping")
                                c.rateLimiter.OnSuccess()
                                skippedCount++
                                continue</span>
                        }

                        <span class="cov8" title="1">if strings.Contains(errStr, "invite_only") </span><span class="cov8" title="1">{
                                logger.WithField("channel", ch.Name).Debug("Channel is invite-only, skipping")
                                c.rateLimiter.OnSuccess()
                                skippedCount++
                                continue</span>
                        }

                        // Missing scope or permissions - this is fatal for the bot's functionality
                        <span class="cov8" title="1">if strings.Contains(errStr, "missing_scope") </span><span class="cov8" title="1">{
                                return joinedCount, fmt.Errorf("missing required OAuth scope to join channels. Your bot needs the 'channels:join' OAuth scope.\nPlease add this scope in your Slack app settings at https://api.slack.com/apps")
                        }</span>

                        <span class="cov8" title="1">if strings.Contains(errStr, "invalid_auth") </span><span class="cov8" title="1">{
                                return joinedCount, fmt.Errorf("invalid authentication token: %w", err)
                        }</span>

                        // Other errors are fatal - we need to be able to join channels for accurate analysis
                        <span class="cov0" title="0">fatalErrors = append(fatalErrors, fmt.Sprintf("%s: %s", ch.Name, errStr))
                        continue</span>
                }

                <span class="cov8" title="1">c.rateLimiter.OnSuccess()
                joinedCount++
                logger.WithField("channel", ch.Name).Debug("Successfully joined channel")</span>
        }

        <span class="cov8" title="1">logger.WithFields(logger.LogFields{
                "joined":  joinedCount,
                "skipped": skippedCount,
                "total":   len(channels),
        }).Info("Auto-join summary")

        if len(fatalErrors) &gt; 0 </span><span class="cov0" title="0">{
                return joinedCount, fmt.Errorf("failed to join %d channels, cannot proceed with accurate analysis: %v", len(fatalErrors), fatalErrors)
        }</span>

        <span class="cov8" title="1">return joinedCount, nil</span>
}

func (c *Client) shouldSkipChannel(channelName string) bool <span class="cov8" title="1">{
        // Skip channels that should never be archived
        excludePatterns := []string{
                "general",
                "random",
                "announcements",
                "admin",
                "hr",
                "security",
        }

        lowerName := strings.ToLower(channelName)
        for _, pattern := range excludePatterns </span><span class="cov8" title="1">{
                if strings.Contains(lowerName, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (c *Client) seemsActiveFromMetadata(ch slack.Channel, warnCutoff time.Time) bool <span class="cov8" title="1">{
        // ONLY use metadata that directly indicates recent message activity
        // No guessing based on member counts, topics, etc.

        // Debug: Show what metadata we have for this channel
        hasLatest := ch.Latest != nil
        latestTimestamp := ""
        if hasLatest </span><span class="cov8" title="1">{
                latestTimestamp = ch.Latest.Timestamp
        }</span>

        <span class="cov8" title="1">logger.WithFields(logger.LogFields{
                "channel":          ch.Name,
                "has_latest":       hasLatest,
                "latest_timestamp": latestTimestamp,
                "warn_cutoff":      warnCutoff.Format("2006-01-02 15:04:05"),
        }).Debug("Checking channel metadata for activity")

        // Check if the channel itself has a "latest" timestamp that's recent
        // Note: Some Slack APIs provide a "latest" field with the timestamp of the last message
        if ch.Latest != nil &amp;&amp; ch.Latest.Timestamp != "" </span><span class="cov8" title="1">{
                latestMsgTime, err := parseSlackTimestamp(ch.Latest.Timestamp)
                if err == nil </span><span class="cov8" title="1">{
                        logger.WithFields(logger.LogFields{
                                "channel":         ch.Name,
                                "latest_msg":      latestMsgTime.Format("2006-01-02 15:04:05"),
                                "is_after_cutoff": latestMsgTime.After(warnCutoff),
                        }).Debug("Parsed latest message timestamp")

                        if latestMsgTime.After(warnCutoff) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                } else<span class="cov8" title="1"> {
                        logger.WithFields(logger.LogFields{
                                "channel":   ch.Name,
                                "timestamp": ch.Latest.Timestamp,
                                "error":     err.Error(),
                        }).Debug("Failed to parse latest timestamp")
                }</span>
        }

        // If no direct message timestamp metadata is available, we need to check message history
        // Don't make any assumptions - let the message history check decide
        <span class="cov8" title="1">return false</span>
}

func (c *Client) getBotUserID() string <span class="cov8" title="1">{
        // Cache the bot user ID to avoid repeated API calls
        if auth, err := c.api.AuthTest(); err == nil </span><span class="cov8" title="1">{
                return auth.UserID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func parseSlackTimestamp(ts string) (time.Time, error) <span class="cov8" title="1">{
        // Slack timestamps are in format "1234567890.123456"
        parts := strings.Split(ts, ".")
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("invalid timestamp format")
        }</span>

        <span class="cov8" title="1">seconds, err := strconv.ParseInt(parts[0], 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return time.Time{}, err
        }</span>

        <span class="cov8" title="1">return time.Unix(seconds, 0), nil</span>
}

func (c *Client) WarnInactiveChannel(channel Channel, warnSeconds, archiveSeconds int) error <span class="cov8" title="1">{
        // First, try to join the channel if it's public
        if err := c.ensureBotInChannel(channel); err != nil </span><span class="cov8" title="1">{
                logger.WithFields(logger.LogFields{
                        "channel": channel.Name,
                        "error":   err.Error(),
                }).Warn("Could not join channel, skipping warning")
                return fmt.Errorf("failed to join channel %s: %w", channel.Name, err)
        }</span>

        <span class="cov8" title="1">message := c.FormatInactiveChannelWarning(channel, warnSeconds, archiveSeconds)

        logger.WithFields(logger.LogFields{
                "channel":         channel.Name,
                "archive_seconds": archiveSeconds,
        }).Debug("Posting inactive channel warning")

        return c.postMessageToChannelID(channel.ID, message)</span>
}

func (c *Client) ensureBotInChannel(channel Channel) error <span class="cov8" title="1">{
        logger.WithField("channel", channel.Name).Debug("Ensuring bot is in channel")

        // Rate limit before API call
        ctx, cancel := context.WithTimeout(context.Background(), time.Minute*2)
        defer cancel()

        if err := c.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("rate limiter cancelled: %w", err)
        }</span>

        <span class="cov8" title="1">_, _, _, err := c.api.JoinConversation(channel.ID)
        if err != nil </span><span class="cov8" title="1">{
                errStr := err.Error()
                logger.WithFields(logger.LogFields{
                        "channel":   channel.Name,
                        "error":     errStr,
                        "operation": "join_conversation",
                }).Debug("Join conversation result")

                // Handle rate limiting
                if strings.Contains(errStr, "rate_limited") </span><span class="cov0" title="0">{
                        c.rateLimiter.OnRateLimitError()
                        return fmt.Errorf("rate limited by Slack API. Will retry with exponential backoff on next request")
                }</span>

                // Handle expected errors that we can ignore
                <span class="cov8" title="1">if strings.Contains(errStr, "already_in_channel") </span><span class="cov0" title="0">{
                        logger.WithField("channel", channel.Name).Debug("Bot already in channel")
                        c.rateLimiter.OnSuccess()
                        return nil
                }</span>

                // Handle permission errors
                <span class="cov8" title="1">if strings.Contains(errStr, "missing_scope") </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing required permission to join channels. Your bot needs the 'channels:join' OAuth scope.\nPlease add this scope in your Slack app settings at https://api.slack.com/apps")
                }</span>

                <span class="cov8" title="1">if strings.Contains(errStr, "channel_not_found") </span><span class="cov0" title="0">{
                        return fmt.Errorf("channel '%s' not found", channel.Name)
                }</span>

                <span class="cov8" title="1">if strings.Contains(errStr, "is_archived") </span><span class="cov0" title="0">{
                        return fmt.Errorf("channel '%s' is archived", channel.Name)
                }</span>

                <span class="cov8" title="1">if strings.Contains(errStr, "invite_only") </span><span class="cov0" title="0">{
                        logger.WithField("channel", channel.Name).Debug("Channel is private/invite-only, cannot join")
                        return fmt.Errorf("channel '%s' is private or invite-only", channel.Name)
                }</span>

                // For other errors, log but don't fail completely
                <span class="cov8" title="1">logger.WithFields(logger.LogFields{
                        "channel": channel.Name,
                        "error":   errStr,
                }).Warn("Unexpected error joining channel")
                return fmt.Errorf("failed to join channel %s: %w", channel.Name, err)</span>
        }

        <span class="cov8" title="1">c.rateLimiter.OnSuccess()
        logger.WithField("channel", channel.Name).Info("Successfully joined channel")
        return nil</span>
}

func (c *Client) postMessageToChannelID(channelID, message string) error <span class="cov8" title="1">{
        logger.WithFields(logger.LogFields{
                "channel_id":     channelID,
                "message_length": len(message),
        }).Debug("Posting message to channel by ID")

        // Rate limit before API call
        ctx, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        if err := c.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("rate limiter cancelled: %w", err)
        }</span>

        <span class="cov8" title="1">_, _, err := c.api.PostMessage(channelID, slack.MsgOptionText(message, false))
        if err != nil </span><span class="cov8" title="1">{
                errStr := err.Error()
                logger.WithFields(logger.LogFields{
                        "channel_id": channelID,
                        "error":      errStr,
                        "operation":  "post_message",
                }).Error("Failed to post message to Slack")

                // Handle rate limiting
                if strings.Contains(errStr, "rate_limited") </span><span class="cov8" title="1">{
                        c.rateLimiter.OnRateLimitError()
                        return fmt.Errorf("rate limited by Slack API. Will retry with exponential backoff on next request")
                }</span>

                <span class="cov8" title="1">if strings.Contains(errStr, "missing_scope") </span><span class="cov8" title="1">{
                        logger.Error("Missing chat:write OAuth scope")
                        return fmt.Errorf("missing required permission to post messages. Your bot needs the 'chat:write' OAuth scope.\nPlease add this scope in your Slack app settings at https://api.slack.com/apps")
                }</span>
                <span class="cov8" title="1">if strings.Contains(errStr, "channel_not_found") </span><span class="cov8" title="1">{
                        logger.WithField("channel_id", channelID).Error("Channel not found")
                        return fmt.Errorf("channel with ID '%s' not found. Make sure the bot is added to the channel", channelID)
                }</span>
                <span class="cov8" title="1">if strings.Contains(errStr, "not_in_channel") </span><span class="cov8" title="1">{
                        logger.WithField("channel_id", channelID).Error("Bot not in channel")
                        return fmt.Errorf("bot is not a member of channel with ID '%s'. Please add the bot to the channel", channelID)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("failed to post message to channel %s: %w", channelID, err)</span>
        }

        // Mark successful API call
        <span class="cov8" title="1">c.rateLimiter.OnSuccess()

        logger.WithField("channel_id", channelID).Debug("Message posted successfully")
        return nil</span>
}

func (c *Client) FormatInactiveChannelWarning(channel Channel, warnSeconds, archiveSeconds int) string <span class="cov8" title="1">{
        var builder strings.Builder

        builder.WriteString("🚨 **Inactive Channel Warning** 🚨\n\n")

        // Format warn period in human readable format
        warnText := fmt.Sprintf("%d seconds", warnSeconds)
        if warnSeconds &gt;= 60 </span><span class="cov8" title="1">{
                minutes := warnSeconds / 60
                if minutes == 1 </span><span class="cov8" title="1">{
                        warnText = "1 minute"
                }</span> else<span class="cov8" title="1"> if minutes &lt; 60 </span><span class="cov8" title="1">{
                        warnText = fmt.Sprintf("%d minutes", minutes)
                }</span> else<span class="cov8" title="1"> {
                        hours := minutes / 60
                        if hours == 1 </span><span class="cov8" title="1">{
                                warnText = "1 hour"
                        }</span> else<span class="cov8" title="1"> if hours &lt; 24 </span><span class="cov8" title="1">{
                                warnText = fmt.Sprintf("%d hours", hours)
                        }</span> else<span class="cov8" title="1"> {
                                days := hours / 24
                                if days == 1 </span><span class="cov8" title="1">{
                                        warnText = "1 day"
                                }</span> else<span class="cov8" title="1"> {
                                        warnText = fmt.Sprintf("%d days", days)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">builder.WriteString(fmt.Sprintf("This channel has been inactive for more than %s.\n\n", warnText))

        // Convert seconds to human readable format
        archiveText := fmt.Sprintf("%d seconds", archiveSeconds)
        if archiveSeconds &gt;= 60 </span><span class="cov8" title="1">{
                minutes := archiveSeconds / 60
                if minutes == 1 </span><span class="cov8" title="1">{
                        archiveText = "1 minute"
                }</span> else<span class="cov8" title="1"> {
                        archiveText = fmt.Sprintf("%d minutes", minutes)
                }</span>
        }

        <span class="cov8" title="1">builder.WriteString(fmt.Sprintf("**This channel will be archived in %s** unless new messages are posted.\n\n", archiveText))

        builder.WriteString("To keep this channel active:\n")
        builder.WriteString("• Post a message in this channel\n")
        builder.WriteString("• Or contact an admin if this channel should remain active\n\n")

        builder.WriteString("_This is an automated message from slack-buddy bot._\n")
        builder.WriteString("&lt;!-- inactive channel warning --&gt;")

        return builder.String()</span>
}

func (c *Client) FormatChannelArchivalMessage(channel Channel, warnSeconds, archiveSeconds int) string <span class="cov8" title="1">{
        var builder strings.Builder

        builder.WriteString("📋 **Channel Archival Notice** 📋\n\n")

        // Format warn period in human readable format
        warnText := fmt.Sprintf("%d seconds", warnSeconds)
        if warnSeconds &gt;= 60 </span><span class="cov8" title="1">{
                minutes := warnSeconds / 60
                if minutes == 1 </span><span class="cov0" title="0">{
                        warnText = "1 minute"
                }</span> else<span class="cov8" title="1"> if minutes &lt; 60 </span><span class="cov8" title="1">{
                        warnText = fmt.Sprintf("%d minutes", minutes)
                }</span> else<span class="cov8" title="1"> {
                        hours := minutes / 60
                        if hours == 1 </span><span class="cov0" title="0">{
                                warnText = "1 hour"
                        }</span> else<span class="cov8" title="1"> if hours &lt; 24 </span><span class="cov8" title="1">{
                                warnText = fmt.Sprintf("%d hours", hours)
                        }</span> else<span class="cov0" title="0"> {
                                days := hours / 24
                                if days == 1 </span><span class="cov0" title="0">{
                                        warnText = "1 day"
                                }</span> else<span class="cov0" title="0"> {
                                        warnText = fmt.Sprintf("%d days", days)
                                }</span>
                        }
                }
        }

        // Format archive period in human readable format
        <span class="cov8" title="1">archiveText := fmt.Sprintf("%d seconds", archiveSeconds)
        if archiveSeconds &gt;= 60 </span><span class="cov8" title="1">{
                minutes := archiveSeconds / 60
                if minutes == 1 </span><span class="cov8" title="1">{
                        archiveText = "1 minute"
                }</span> else<span class="cov8" title="1"> if minutes &lt; 60 </span><span class="cov0" title="0">{
                        archiveText = fmt.Sprintf("%d minutes", minutes)
                }</span> else<span class="cov8" title="1"> {
                        hours := minutes / 60
                        if hours == 1 </span><span class="cov8" title="1">{
                                archiveText = "1 hour"
                        }</span> else<span class="cov0" title="0"> if hours &lt; 24 </span><span class="cov0" title="0">{
                                archiveText = fmt.Sprintf("%d hours", hours)
                        }</span> else<span class="cov0" title="0"> {
                                days := hours / 24
                                if days == 1 </span><span class="cov0" title="0">{
                                        archiveText = oneDayText
                                }</span> else<span class="cov0" title="0"> {
                                        archiveText = strconv.Itoa(days) + " days"
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">builder.WriteString(fmt.Sprintf("This channel is being archived because:\n"))
        builder.WriteString(fmt.Sprintf("• It was inactive for more than %s (warning threshold)\n", warnText))
        builder.WriteString(fmt.Sprintf("• An inactivity warning was posted\n"))
        builder.WriteString(fmt.Sprintf("• No new activity occurred within %s after the warning (archive threshold)\n\n", archiveText))

        builder.WriteString("**This channel is now being archived.**\n\n")

        builder.WriteString("If this channel should not have been archived, please contact a workspace admin.\n\n")

        builder.WriteString("_This is an automated action by slack-buddy bot._\n")
        builder.WriteString("&lt;!-- channel archival notice --&gt;")

        return builder.String()</span>
}

func (c *Client) ArchiveChannel(channel Channel) error <span class="cov8" title="1">{
        // Legacy method for backward compatibility - uses default thresholds
        return c.ArchiveChannelWithThresholds(channel, 300, 60) // 5 minutes warn, 1 minute archive
}</span>

func (c *Client) ArchiveChannelWithThresholds(channel Channel, warnSeconds, archiveSeconds int) error <span class="cov8" title="1">{
        logger.WithField("channel", channel.Name).Debug("Archiving inactive channel")

        // First, ensure the bot is in the channel to post the archival message
        if err := c.ensureBotInChannel(channel); err != nil </span><span class="cov8" title="1">{
                logger.WithFields(logger.LogFields{
                        "channel": channel.Name,
                        "error":   err.Error(),
                }).Warn("Could not join channel for archival message, proceeding with archival anyway")
                // Don't fail here - we can still archive even if we can't post the message
        }</span>

        // Post archival message explaining why the channel is being archived
        <span class="cov8" title="1">archivalMessage := c.FormatChannelArchivalMessage(channel, warnSeconds, archiveSeconds)
        if err := c.postMessageToChannelID(channel.ID, archivalMessage); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(logger.LogFields{
                        "channel": channel.Name,
                        "error":   err.Error(),
                }).Warn("Failed to post archival message, proceeding with archival anyway")
                // Don't fail here - archival should proceed even if the message fails
        }</span> else<span class="cov8" title="1"> {
                logger.WithField("channel", channel.Name).Info("Posted archival message successfully")
        }</span>

        // Rate limit before archival API call
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), time.Minute*2)
        defer cancel()

        if err := c.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("rate limiter cancelled: %w", err)
        }</span>

        <span class="cov8" title="1">err := c.api.ArchiveConversation(channel.ID)
        if err != nil </span><span class="cov8" title="1">{
                errStr := err.Error()
                logger.WithFields(logger.LogFields{
                        "channel":   channel.Name,
                        "error":     errStr,
                        "operation": "archive_conversation",
                }).Error("Failed to archive channel")

                // Handle rate limiting
                if strings.Contains(errStr, "rate_limited") </span><span class="cov0" title="0">{
                        c.rateLimiter.OnRateLimitError()
                        return fmt.Errorf("rate limited by Slack API. Will retry with exponential backoff on next request")
                }</span>

                <span class="cov8" title="1">if strings.Contains(errStr, "missing_scope") </span><span class="cov8" title="1">{
                        return fmt.Errorf("missing required permission to archive channels. Your bot needs the 'channels:manage' OAuth scope.\nPlease add this scope in your Slack app settings at https://api.slack.com/apps")
                }</span>

                <span class="cov8" title="1">if strings.Contains(errStr, "channel_not_found") </span><span class="cov0" title="0">{
                        return fmt.Errorf("channel '%s' not found", channel.Name)
                }</span>

                <span class="cov8" title="1">if strings.Contains(errStr, "already_archived") </span><span class="cov8" title="1">{
                        logger.WithField("channel", channel.Name).Info("Channel was already archived")
                        return nil
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("failed to archive channel %s: %w", channel.Name, err)</span>
        }

        <span class="cov8" title="1">c.rateLimiter.OnSuccess()
        logger.WithField("channel", channel.Name).Info("Channel archived successfully")
        return nil</span>
}

func (c *Client) GetChannelsWithMetadata() ([]Channel, error) <span class="cov8" title="1">{
        logger.Debug("Fetching channels with metadata from Slack API")

        // Rate limit before API call
        ctx, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        if err := c.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rate limiter cancelled: %w", err)
        }</span>

        <span class="cov8" title="1">channels, _, err := c.api.GetConversations(&amp;slack.GetConversationsParameters{
                Types: []string{"public_channel", "private_channel"},
                Limit: 1000,
        })
        if err != nil </span><span class="cov8" title="1">{
                errStr := err.Error()
                logger.WithFields(logger.LogFields{
                        "error":     errStr,
                        "operation": "get_conversations",
                }).Error("Slack API error")

                // Handle rate limiting
                if strings.Contains(errStr, "rate_limited") </span><span class="cov0" title="0">{
                        c.rateLimiter.OnRateLimitError()
                        return nil, fmt.Errorf("rate limited by Slack API. Will retry with exponential backoff on next request")
                }</span>

                <span class="cov8" title="1">if strings.Contains(errStr, "missing_scope") </span><span class="cov0" title="0">{
                        logger.Error("Missing OAuth scopes for channel access")
                        return nil, fmt.Errorf("missing required permissions. Your bot needs these OAuth scopes:\\n  - channels:read (to list public channels) - REQUIRED\\n  - groups:read (to list private channels) - OPTIONAL\\n\\nPlease add these scopes in your Slack app settings at https://api.slack.com/apps")
                }</span>
                <span class="cov8" title="1">if strings.Contains(errStr, "invalid_auth") </span><span class="cov0" title="0">{
                        logger.Error("Invalid Slack authentication token")
                        return nil, fmt.Errorf("invalid token. Please check your SLACK_TOKEN")
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("failed to get conversations: %w", err)</span>
        }

        // Mark successful API call
        <span class="cov8" title="1">c.rateLimiter.OnSuccess()

        logger.WithField("total_channels", len(channels)).Debug("Retrieved channels from Slack API")

        var result []Channel
        for _, ch := range channels </span><span class="cov8" title="1">{
                created := time.Unix(int64(ch.Created), 0)

                // Parse the updated timestamp - this appears to be in milliseconds since epoch
                var updated time.Time

                // Try to access the updated field if available in the slack-go library
                // The JSON shows "updated": 1678229664302 (milliseconds since epoch)
                // Let's check what's available on the Channel struct

                // Try to access the actual "updated" field from the Slack API
                // The slack-go library may not expose this field directly

                // Let me try to see if there's a direct Updated field
                // Based on the JSON, this should be "updated": 1678229664302 (milliseconds since epoch)

                // Check for various possible field names
                // Since slack-go might expose it as a different field...
                // Let's add some debug info to see what's actually available

                // For the dev command, we'll show channel creation time
                // This is useful for understanding when channels were created
                // Note: This is NOT the same as last message activity

                // Try to get latest message timestamp if available
                if ch.Latest != nil &amp;&amp; ch.Latest.Timestamp != "" </span><span class="cov0" title="0">{
                        if latestTime, err := parseSlackTimestamp(ch.Latest.Timestamp); err == nil </span><span class="cov0" title="0">{
                                updated = latestTime
                        }</span>
                }

                // Fallback to creation time (which is what we typically see)
                <span class="cov8" title="1">if updated.IsZero() </span><span class="cov8" title="1">{
                        updated = created
                }</span>

                <span class="cov8" title="1">result = append(result, Channel{
                        ID:          ch.ID,
                        Name:        ch.Name,
                        Created:     created,
                        Updated:     updated,
                        Purpose:     ch.Purpose.Value,
                        Creator:     ch.Creator,
                        MemberCount: ch.NumMembers,
                        IsArchived:  ch.IsArchived,
                })</span>
        }

        <span class="cov8" title="1">logger.WithField("channels_count", len(result)).Debug("Channel metadata extraction completed")
        return result, nil</span>
}

// GetChannelActivity returns the last activity time, warning status, and warning time for a channel
func (c *Client) GetChannelActivity(channelID string) (lastActivity time.Time, hasWarning bool, warningTime time.Time, err error) <span class="cov8" title="1">{
        return c.getChannelActivity(channelID)
}</span>

// MessageInfo contains details about a message
type MessageInfo struct {
        Timestamp time.Time
        User      string
        UserName  string // Human-readable name
        Text      string
        IsBot     bool
}

// GetChannelActivityWithMessage returns activity info plus details about the most recent message
func (c *Client) GetChannelActivityWithMessage(channelID string) (lastActivity time.Time, hasWarning bool, warningTime time.Time, lastMessage *MessageInfo, err error) <span class="cov8" title="1">{
        const maxRetries = 3
        var history *slack.GetConversationHistoryResponse

        for attempt := 1; attempt &lt;= maxRetries; attempt++ </span><span class="cov8" title="1">{
                // Rate limit before API call
                ctx, cancel := context.WithTimeout(context.Background(), time.Second*10)

                if err := c.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                        cancel()
                        return time.Time{}, false, time.Time{}, nil, fmt.Errorf("rate limiter cancelled: %w", err)
                }</span>
                <span class="cov8" title="1">cancel()

                // Get recent messages to find the most recent real one
                params := &amp;slack.GetConversationHistoryParameters{
                        ChannelID: channelID,
                        Limit:     10, // Get more messages to find real ones past any system messages
                }

                history, err = c.api.GetConversationHistory(params)
                if err != nil </span><span class="cov0" title="0">{
                        errStr := err.Error()

                        // Handle rate limiting with retry
                        if strings.Contains(errStr, "rate_limited") || strings.Contains(errStr, "rate limit") </span><span class="cov0" title="0">{


                                // If not the last attempt, continue to retry
                                if attempt &lt; maxRetries </span><span class="cov0" title="0">{
                                        // Parse Slack's retry-after directive
                                        waitDuration := parseSlackRetryAfter(errStr)
                                        if waitDuration &gt; 0 </span><span class="cov0" title="0">{
                                                // Wait for the specified duration quietly without verbose output
                                                showProgressBar(waitDuration)
                                        }</span> else<span class="cov0" title="0"> {
                                                // Fallback to our rate limiter if we can't parse Slack's directive
                                                c.rateLimiter.OnRateLimitError()
                                                // Use fallback backoff quietly without verbose output
                                        }</span>
                                        <span class="cov0" title="0">continue</span>
                                }
                                // Last attempt failed, return error
                                // All retry attempts failed, proceeding to return error
                                <span class="cov0" title="0">return time.Time{}, false, time.Time{}, nil, fmt.Errorf("failed to get channel history after %d attempts, final Slack error: %s", maxRetries, errStr)</span>
                        }

                        // Non-rate-limit errors - don't retry
                        <span class="cov0" title="0">return time.Time{}, false, time.Time{}, nil, fmt.Errorf("failed to get channel history: %w", err)</span>
                }

                // Success - break out of retry loop
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">c.rateLimiter.OnSuccess()

        if len(history.Messages) == 0 </span><span class="cov0" title="0">{
                // No messages
                return time.Time{}, false, time.Time{}, nil, nil
        }</span>

        // Find the most recent "real" message (not join/leave/system messages)
        <span class="cov8" title="1">botUserID := c.getBotUserID()
        var lastRealMsg *slack.Message
        var lastRealMsgTime time.Time

        for _, msg := range history.Messages </span><span class="cov8" title="1">{
                if isRealMessage(msg, botUserID) </span><span class="cov8" title="1">{
                        lastRealMsg = &amp;msg
                        if msgTime, err := parseSlackTimestamp(msg.Timestamp); err == nil </span><span class="cov8" title="1">{
                                lastRealMsgTime = msgTime
                        }</span>
                        <span class="cov8" title="1">break</span> // Found the most recent real message
                }
        }

        // If no real messages found, check if we need to look deeper
        <span class="cov8" title="1">if lastRealMsg == nil </span><span class="cov0" title="0">{
                // No real messages in the first message, might need to get more history
                // For now, return no activity
                return time.Time{}, false, time.Time{}, nil, nil
        }</span>

        // Create message info for the real message
        <span class="cov8" title="1">msgInfo := &amp;MessageInfo{
                Timestamp: lastRealMsgTime,
                User:      lastRealMsg.User,
                Text:      lastRealMsg.Text,
                IsBot:     lastRealMsg.User == botUserID,
        }

        // Check if this is a warning message from our bot
        hasWarningMessage := lastRealMsg.User == botUserID &amp;&amp; strings.Contains(lastRealMsg.Text, "inactive channel warning")
        var mostRecentWarning time.Time
        if hasWarningMessage </span><span class="cov0" title="0">{
                mostRecentWarning = lastRealMsgTime
        }</span>

        <span class="cov8" title="1">return lastRealMsgTime, hasWarningMessage, mostRecentWarning, msgInfo, nil</span>
}

// parseSlackRetryAfter parses Slack's "retry after" directive from error messages
// Example: "slack rate limit exceeded, retry after 1m0s" -&gt; 1 minute duration
func parseSlackRetryAfter(errorStr string) time.Duration <span class="cov8" title="1">{
        // Look for "retry after" followed by a duration
        retryAfterIndex := strings.Index(errorStr, "retry after ")
        if retryAfterIndex == -1 </span><span class="cov8" title="1">{
                return 0
        }</span>

        // Extract the duration part
        <span class="cov8" title="1">durationStart := retryAfterIndex + len("retry after ")
        remaining := errorStr[durationStart:]

        // Find the end of the duration (usually end of string or a space)
        var durationStr string
        spaceIndex := strings.Index(remaining, " ")
        if spaceIndex == -1 </span><span class="cov8" title="1">{
                durationStr = remaining
        }</span> else<span class="cov8" title="1"> {
                durationStr = remaining[:spaceIndex]
        }</span>

        // Parse the duration using Go's time.ParseDuration
        <span class="cov8" title="1">duration, err := time.ParseDuration(durationStr)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithFields(logger.LogFields{
                        "error_string":  errorStr,
                        "duration_part": durationStr,
                        "parse_error":   err.Error(),
                }).Warn("Failed to parse Slack retry-after duration")
                return 0
        }</span>

        // Add 1 second buffer to avoid hitting the limit again immediately
        <span class="cov8" title="1">bufferedDuration := duration + (1 * time.Second)


        return bufferedDuration</span>
}

// showProgressBar displays a text-based progress bar for waiting periods
// Shows - for remaining time and * for elapsed time
func showProgressBar(duration time.Duration) <span class="cov8" title="1">{
        totalSeconds := int(duration.Seconds())
        if totalSeconds &lt;= 0 </span><span class="cov8" title="1">{
                return
        }</span>

        // Limit to reasonable max for display (2 minutes = 120 chars)
        <span class="cov0" title="0">maxDisplay := 120
        if totalSeconds &gt; maxDisplay </span><span class="cov0" title="0">{
                // Scale down for very long waits
                scaleFactor := float64(totalSeconds) / float64(maxDisplay)
                fmt.Printf("   Progress (scaled 1:%d): ", int(scaleFactor))
                totalSeconds = maxDisplay
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("   Progress: ")
        }</span>

        // Print initial bar (all dashes)
        <span class="cov0" title="0">for i := 0; i &lt; totalSeconds; i++ </span><span class="cov0" title="0">{
                fmt.Printf("-")
        }</span>
        <span class="cov0" title="0">fmt.Printf(" [0/%ds]\r", int(duration.Seconds()))

        // Update progress each second
        for elapsed := 0; elapsed &lt; totalSeconds; elapsed++ </span><span class="cov0" title="0">{
                time.Sleep(time.Second)

                // Move cursor to start of progress bar
                fmt.Printf("   Progress: ")
                if totalSeconds &gt; maxDisplay </span><span class="cov0" title="0">{
                        fmt.Printf("(scaled 1:%d): ", int(float64(int(duration.Seconds()))/float64(maxDisplay)))
                }</span>

                // Print progress: * for completed, - for remaining
                <span class="cov0" title="0">for i := 0; i &lt; totalSeconds; i++ </span><span class="cov0" title="0">{
                        if i &lt;= elapsed </span><span class="cov0" title="0">{
                                fmt.Printf("*")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("-")
                        }</span>
                }
                <span class="cov0" title="0">fmt.Printf(" [%d/%ds]\r", elapsed+1, int(duration.Seconds()))</span>
        }

        // Final newline
        <span class="cov0" title="0">fmt.Printf("\n   ✅ Wait complete!\n")</span>
}

// isRealMessage filters out system messages like joins, leaves, topic changes, etc.
// Returns true for actual user-generated content
func isRealMessage(msg slack.Message, botUserID string) bool <span class="cov8" title="1">{
        // Filter out messages with system subtypes
        if msg.SubType != "" </span><span class="cov8" title="1">{
                systemSubtypes := []string{
                        "channel_join",
                        "channel_leave",
                        "channel_topic",
                        "channel_purpose",
                        "channel_name",
                        "channel_archive",
                        "channel_unarchive",
                        "group_join",
                        "group_leave",
                        "group_topic",
                        "group_purpose",
                        "group_name",
                        "group_archive",
                        "group_unarchive",
                        "bot_add",
                        "bot_remove",
                        "pinned_item",
                        "unpinned_item",
                }

                for _, systemType := range systemSubtypes </span><span class="cov8" title="1">{
                        if msg.SubType == systemType </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }

        // Filter out join/leave messages by content patterns
        <span class="cov8" title="1">text := msg.Text
        joinLeavePatterns := []string{
                "has joined the channel",
                "has left the channel",
                "has joined the group",
                "has left the group",
                "set the channel topic:",
                "set the channel purpose:",
                "renamed the channel from",
                "archived this channel",
                "unarchived this channel",
                "pinned a message to this channel",
                "unpinned a message from this channel",
        }

        for _, pattern := range joinLeavePatterns </span><span class="cov8" title="1">{
                if strings.Contains(text, pattern) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Filter out empty messages
        <span class="cov8" title="1">if strings.TrimSpace(text) == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // All other messages are considered "real"
        <span class="cov8" title="1">return true</span>
}

// getUserMap fetches all users and builds a map from user ID to display name
func (c *Client) getUserMap() (map[string]string, error) <span class="cov8" title="1">{
        // Rate limit before API call
        ctx, cancel := context.WithTimeout(context.Background(), time.Minute*2)
        defer cancel()

        if err := c.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rate limiter cancelled: %w", err)
        }</span>

        <span class="cov8" title="1">users, err := c.api.GetUsers()
        if err != nil </span><span class="cov8" title="1">{
                errStr := err.Error()
                logger.WithFields(logger.LogFields{
                        "error":          errStr,
                        "operation":      "get_users",
                        "required_scope": "users:read",
                }).Error("Failed to get users list")

                // Handle rate limiting
                if strings.Contains(errStr, "rate_limited") || strings.Contains(errStr, "rate limit") </span><span class="cov0" title="0">{
                        c.rateLimiter.OnRateLimitError()
                        return nil, fmt.Errorf("rate limited getting users: %w", err)
                }</span>

                // Handle missing scope with clearer message
                <span class="cov8" title="1">if strings.Contains(errStr, "missing_scope") </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("missing required OAuth scope 'users:read' to get user list: %w", err)
                }</span>

                <span class="cov8" title="1">return nil, fmt.Errorf("failed to get users: %w", err)</span>
        }

        <span class="cov8" title="1">c.rateLimiter.OnSuccess()

        // Build the map
        userMap := make(map[string]string)
        for _, user := range users </span><span class="cov8" title="1">{
                displayName := user.RealName
                if displayName == "" </span><span class="cov8" title="1">{
                        displayName = user.Name
                }</span>
                <span class="cov8" title="1">if displayName == "" </span><span class="cov8" title="1">{
                        displayName = user.Profile.DisplayName
                }</span>
                <span class="cov8" title="1">if displayName == "" </span><span class="cov8" title="1">{
                        displayName = user.ID // Fallback to ID if no name available
                }</span>
                <span class="cov8" title="1">userMap[user.ID] = displayName</span>
        }

        <span class="cov8" title="1">logger.WithField("user_count", len(userMap)).Debug("Built user lookup map")
        return userMap, nil</span>
}

// GetUserMap is a public wrapper for getUserMap
func (c *Client) GetUserMap() (map[string]string, error) <span class="cov8" title="1">{
        return c.getUserMap()
}</span>

// GetChannelActivityWithMessageAndUsers returns activity info plus message details with resolved user names
func (c *Client) GetChannelActivityWithMessageAndUsers(channelID string, userMap map[string]string) (lastActivity time.Time, hasWarning bool, warningTime time.Time, lastMessage *MessageInfo, err error) <span class="cov8" title="1">{
        // Get the basic activity info
        lastActivity, hasWarning, warningTime, basicMessage, err := c.GetChannelActivityWithMessage(channelID)
        if err != nil || basicMessage == nil </span><span class="cov0" title="0">{
                return lastActivity, hasWarning, warningTime, basicMessage, err
        }</span>

        // Resolve the user name
        <span class="cov8" title="1">userName := userMap[basicMessage.User]
        if userName == "" </span><span class="cov0" title="0">{
                userName = basicMessage.User // Fallback to ID if not found
        }</span>

        // Create enhanced message info with resolved name
        <span class="cov8" title="1">enhancedMessage := &amp;MessageInfo{
                Timestamp: basicMessage.Timestamp,
                User:      basicMessage.User,
                UserName:  userName,
                Text:      basicMessage.Text,
                IsBot:     basicMessage.IsBot,
        }

        return lastActivity, hasWarning, warningTime, enhancedMessage, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package slack

import (
        "github.com/slack-go/slack"
)

// SlackAPI defines the interface for Slack API operations.
type SlackAPI interface {
        AuthTest() (*slack.AuthTestResponse, error)
        GetConversations(params *slack.GetConversationsParameters) ([]slack.Channel, string, error)
        GetConversationHistory(params *slack.GetConversationHistoryParameters) (*slack.GetConversationHistoryResponse, error)
        PostMessage(channelID string, options ...slack.MsgOption) (string, string, error)
        ArchiveConversation(channelID string) error
        JoinConversation(channelID string) (*slack.Channel, string, []string, error)
        GetUsers() ([]slack.User, error)
}

// RealSlackAPI wraps the actual Slack API client.
type RealSlackAPI struct {
        client *slack.Client
}

// NewRealSlackAPI creates a new real Slack API wrapper.
func NewRealSlackAPI(token string) *RealSlackAPI <span class="cov8" title="1">{
        return &amp;RealSlackAPI{
                client: slack.New(token),
        }
}</span>

func (r *RealSlackAPI) AuthTest() (*slack.AuthTestResponse, error) <span class="cov8" title="1">{
        return r.client.AuthTest()
}</span>

func (r *RealSlackAPI) GetConversations(params *slack.GetConversationsParameters) ([]slack.Channel, string, error) <span class="cov8" title="1">{
        return r.client.GetConversations(params)
}</span>

func (r *RealSlackAPI) GetConversationHistory(params *slack.GetConversationHistoryParameters) (*slack.GetConversationHistoryResponse, error) <span class="cov8" title="1">{
        return r.client.GetConversationHistory(params)
}</span>

func (r *RealSlackAPI) PostMessage(channelID string, options ...slack.MsgOption) (string, string, error) <span class="cov8" title="1">{
        return r.client.PostMessage(channelID, options...)
}</span>

func (r *RealSlackAPI) ArchiveConversation(channelID string) error <span class="cov8" title="1">{
        return r.client.ArchiveConversation(channelID)
}</span>

func (r *RealSlackAPI) JoinConversation(channelID string) (*slack.Channel, string, []string, error) <span class="cov8" title="1">{
        return r.client.JoinConversation(channelID)
}</span>

func (r *RealSlackAPI) GetUsers() ([]slack.User, error) <span class="cov8" title="1">{
        return r.client.GetUsers()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package slack

import (
        "fmt"
        "time"

        "github.com/slack-go/slack"
)

// Mock error constants
const (
        missingScope    = "missing_scope"
        channelNotFound = "channel_not_found"
)

// MockSlackAPI implements SlackAPI for testing.
type MockSlackAPI struct {
        AuthTestResponse            *slack.AuthTestResponse
        AuthTestError               error
        Channels                    []slack.Channel
        GetConversationsError       error
        GetConversationHistoryError error
        ConversationHistory         map[string][]slack.Message
        ConversationHistoryErrors   map[string]error
        PostMessageError            error
        PostedMessages              []MockMessage
        ArchiveConversationError    error
        ArchiveConversationErrors   map[string]error
        ArchivedChannels            []string
        JoinConversationError       error
        JoinConversationErrors      map[string]error
        JoinedChannels              []string
        Users                       []slack.User
        GetUsersError               error
}

type MockMessage struct {
        ChannelID string
        Text      string
}

// NewMockSlackAPI creates a new mock Slack API.
func NewMockSlackAPI() *MockSlackAPI <span class="cov8" title="1">{
        return &amp;MockSlackAPI{
                AuthTestResponse: &amp;slack.AuthTestResponse{
                        User:   "test-bot",
                        UserID: "U0000000", // Bot's user ID for filtering
                        Team:   "Test Team",
                },
                Channels:                  []slack.Channel{},
                ConversationHistory:       make(map[string][]slack.Message),
                ConversationHistoryErrors: make(map[string]error),
                PostedMessages:            []MockMessage{},
                ArchivedChannels:          []string{},
                ArchiveConversationErrors: make(map[string]error),
                JoinedChannels:            []string{},
                JoinConversationErrors:    make(map[string]error),
                Users:                     []slack.User{},
        }
}</span>

func (m *MockSlackAPI) AuthTest() (*slack.AuthTestResponse, error) <span class="cov8" title="1">{
        if m.AuthTestError != nil </span><span class="cov8" title="1">{
                return nil, m.AuthTestError
        }</span>
        <span class="cov8" title="1">return m.AuthTestResponse, nil</span>
}

func (m *MockSlackAPI) GetConversations(params *slack.GetConversationsParameters) ([]slack.Channel, string, error) <span class="cov8" title="1">{
        if m.GetConversationsError != nil </span><span class="cov8" title="1">{
                return nil, "", m.GetConversationsError
        }</span>
        <span class="cov8" title="1">return m.Channels, "", nil</span>
}

func (m *MockSlackAPI) GetConversationHistory(params *slack.GetConversationHistoryParameters) (*slack.GetConversationHistoryResponse, error) <span class="cov8" title="1">{
        // Check for channel-specific errors first
        if err, exists := m.ConversationHistoryErrors[params.ChannelID]; exists &amp;&amp; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Check for global error
        <span class="cov8" title="1">if m.GetConversationHistoryError != nil </span><span class="cov0" title="0">{
                return nil, m.GetConversationHistoryError
        }</span>

        <span class="cov8" title="1">messages, exists := m.ConversationHistory[params.ChannelID]
        if !exists </span><span class="cov0" title="0">{
                messages = []slack.Message{}
        }</span>

        // Slack API returns messages in reverse chronological order (newest first)
        // So we need to reverse our stored messages
        <span class="cov8" title="1">reversedMessages := make([]slack.Message, len(messages))
        for i, msg := range messages </span><span class="cov8" title="1">{
                reversedMessages[len(messages)-1-i] = msg
        }</span>

        <span class="cov8" title="1">return &amp;slack.GetConversationHistoryResponse{
                Messages: reversedMessages,
        }, nil</span>
}

func (m *MockSlackAPI) PostMessage(channelID string, options ...slack.MsgOption) (string, string, error) <span class="cov8" title="1">{
        if m.PostMessageError != nil </span><span class="cov8" title="1">{
                return "", "", m.PostMessageError
        }</span>

        // For testing purposes, we'll just record that a message was posted
        // Extracting the actual text from slack options is complex, so we use a placeholder
        <span class="cov8" title="1">message := MockMessage{
                ChannelID: channelID,
                Text:      "mock-message-posted", // Simplified for testing
        }
        m.PostedMessages = append(m.PostedMessages, message)

        return "mock-channel-id", "mock-timestamp", nil</span>
}

func (m *MockSlackAPI) ArchiveConversation(channelID string) error <span class="cov8" title="1">{
        // Check for channel-specific errors first
        if err, exists := m.ArchiveConversationErrors[channelID]; exists &amp;&amp; err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Check for global error
        <span class="cov8" title="1">if m.ArchiveConversationError != nil </span><span class="cov0" title="0">{
                return m.ArchiveConversationError
        }</span>

        <span class="cov8" title="1">m.ArchivedChannels = append(m.ArchivedChannels, channelID)
        return nil</span>
}

func (m *MockSlackAPI) JoinConversation(channelID string) (*slack.Channel, string, []string, error) <span class="cov8" title="1">{
        // Check for channel-specific errors first
        if err, exists := m.JoinConversationErrors[channelID]; exists &amp;&amp; err != nil </span><span class="cov8" title="1">{
                return nil, "", nil, err
        }</span>

        // Check for global error
        <span class="cov8" title="1">if m.JoinConversationError != nil </span><span class="cov8" title="1">{
                return nil, "", nil, m.JoinConversationError
        }</span>

        <span class="cov8" title="1">m.JoinedChannels = append(m.JoinedChannels, channelID)

        // Return a mock channel for the joined conversation
        mockChannel := &amp;slack.Channel{
                GroupConversation: slack.GroupConversation{
                        Conversation: slack.Conversation{
                                ID: channelID,
                        },
                },
        }

        return mockChannel, "", []string{}, nil</span>
}

func (m *MockSlackAPI) GetUsers() ([]slack.User, error) <span class="cov8" title="1">{
        if m.GetUsersError != nil </span><span class="cov8" title="1">{
                return nil, m.GetUsersError
        }</span>
        <span class="cov8" title="1">return m.Users, nil</span>
}

// Helper methods for testing

func (m *MockSlackAPI) AddChannel(id, name string, created time.Time, purpose string) <span class="cov8" title="1">{
        m.AddChannelWithCreator(id, name, created, purpose, "U1234567")
}</span>

func (m *MockSlackAPI) AddChannelWithCreator(id, name string, created time.Time, purpose, creator string) <span class="cov8" title="1">{
        channel := slack.Channel{
                GroupConversation: slack.GroupConversation{
                        Conversation: slack.Conversation{
                                ID:      id,
                                Created: slack.JSONTime(created.Unix()),
                        },
                        Name: name,
                        Purpose: slack.Purpose{
                                Value: purpose,
                        },
                        Creator: creator,
                },
        }
        m.Channels = append(m.Channels, channel)
}</span>

func (m *MockSlackAPI) SetAuthError(hasError bool) <span class="cov8" title="1">{
        if hasError </span><span class="cov8" title="1">{
                m.AuthTestError = fmt.Errorf("authentication failed")
        }</span> else<span class="cov8" title="1"> {
                m.AuthTestError = nil
        }</span>
}

func (m *MockSlackAPI) SetGetConversationsError(hasError bool) <span class="cov8" title="1">{
        if hasError </span><span class="cov8" title="1">{
                m.GetConversationsError = fmt.Errorf("failed to get conversations")
        }</span> else<span class="cov8" title="1"> {
                m.GetConversationsError = nil
        }</span>
}

func (m *MockSlackAPI) SetGetConversationsErrorWithMessage(hasError bool, message string) <span class="cov8" title="1">{
        if hasError </span><span class="cov8" title="1">{
                if message == "" </span><span class="cov0" title="0">{
                        message = "failed to get conversations"
                }</span>
                <span class="cov8" title="1">m.GetConversationsError = fmt.Errorf("%s", message)</span>
        } else<span class="cov8" title="1"> {
                m.GetConversationsError = nil
        }</span>
}

func (m *MockSlackAPI) SetPostMessageError(errorType string) <span class="cov8" title="1">{
        switch errorType </span>{
        case missingScope:<span class="cov8" title="1">
                m.PostMessageError = fmt.Errorf(missingScope)</span>
        case channelNotFound:<span class="cov8" title="1">
                m.PostMessageError = fmt.Errorf(channelNotFound)</span>
        case "not_in_channel":<span class="cov8" title="1">
                m.PostMessageError = fmt.Errorf("not_in_channel")</span>
        case "rate_limited":<span class="cov8" title="1">
                m.PostMessageError = fmt.Errorf("rate_limited")</span>
        case "invalid_auth":<span class="cov8" title="1">
                m.PostMessageError = fmt.Errorf("invalid_auth")</span>
        case "generic_error":<span class="cov8" title="1">
                m.PostMessageError = fmt.Errorf("generic error")</span>
        case "":<span class="cov8" title="1">
                m.PostMessageError = nil</span>
        default:<span class="cov8" title="1">
                m.PostMessageError = fmt.Errorf("%s", errorType)</span>
        }
}

func (m *MockSlackAPI) SetJoinError(errorType string) <span class="cov8" title="1">{
        switch errorType </span>{
        case "rate_limited":<span class="cov8" title="1">
                m.JoinConversationError = fmt.Errorf("rate_limited")</span>
        case missingScope:<span class="cov8" title="1">
                m.JoinConversationError = fmt.Errorf(missingScope)</span>
        case "invalid_auth":<span class="cov8" title="1">
                m.JoinConversationError = fmt.Errorf("invalid_auth")</span>
        case "already_in_channel":<span class="cov8" title="1">
                m.JoinConversationError = fmt.Errorf("already_in_channel")</span>
        case "is_archived":<span class="cov8" title="1">
                m.JoinConversationError = fmt.Errorf("is_archived")</span>
        case "invite_only":<span class="cov8" title="1">
                m.JoinConversationError = fmt.Errorf("invite_only")</span>
        case "":<span class="cov0" title="0">
                m.JoinConversationError = nil</span>
        default:<span class="cov0" title="0">
                m.JoinConversationError = fmt.Errorf("%s", errorType)</span>
        }
}

// Additional helper methods for specific error types.
func (m *MockSlackAPI) SetMissingScopeError(hasError bool) <span class="cov8" title="1">{
        if hasError </span><span class="cov8" title="1">{
                m.GetConversationsError = fmt.Errorf(missingScope)
        }</span> else<span class="cov8" title="1"> {
                m.GetConversationsError = nil
        }</span>
}

func (m *MockSlackAPI) SetInvalidAuthError(hasError bool) <span class="cov8" title="1">{
        if hasError </span><span class="cov8" title="1">{
                m.GetConversationsError = fmt.Errorf("invalid_auth")
        }</span> else<span class="cov8" title="1"> {
                m.GetConversationsError = nil
        }</span>
}

func (m *MockSlackAPI) GetPostedMessages() []MockMessage <span class="cov8" title="1">{
        return m.PostedMessages
}</span>

func (m *MockSlackAPI) ClearPostedMessages() <span class="cov8" title="1">{
        m.PostedMessages = []MockMessage{}
}</span>

func (m *MockSlackAPI) AddMessageToHistory(channelID, text, user string, timestamp string) <span class="cov0" title="0">{
        if m.ConversationHistory == nil </span><span class="cov0" title="0">{
                m.ConversationHistory = make(map[string][]slack.Message)
        }</span>

        <span class="cov0" title="0">message := slack.Message{
                Msg: slack.Msg{
                        Type:      "message",
                        Text:      text,
                        User:      user,
                        Timestamp: timestamp,
                },
        }

        m.ConversationHistory[channelID] = append(m.ConversationHistory[channelID], message)</span>
}

func (m *MockSlackAPI) SetConversationHistoryError(hasError bool) <span class="cov0" title="0">{
        if hasError </span><span class="cov0" title="0">{
                m.GetConversationHistoryError = fmt.Errorf("failed to get conversation history")
        }</span> else<span class="cov0" title="0"> {
                m.GetConversationHistoryError = nil
        }</span>
}

// Simulate specific error types.
func (m *MockSlackAPI) SimulateMissingScopeError() <span class="cov8" title="1">{
        m.SetMissingScopeError(true)
}</span>

func (m *MockSlackAPI) SimulateInvalidAuthError() <span class="cov8" title="1">{
        m.SetAuthError(true)
}</span>

func (m *MockSlackAPI) SimulateChannelNotFoundError() <span class="cov8" title="1">{
        m.SetPostMessageError("channel_not_found")
}</span>

func (m *MockSlackAPI) SimulateNotInChannelError() <span class="cov8" title="1">{
        m.SetPostMessageError("not_in_channel")
}</span>

func (m *MockSlackAPI) SetArchiveConversationError(errorType string) <span class="cov0" title="0">{
        switch errorType </span>{
        case "missing_scope":<span class="cov0" title="0">
                m.ArchiveConversationError = fmt.Errorf("missing_scope")</span>
        case "channel_not_found":<span class="cov0" title="0">
                m.ArchiveConversationError = fmt.Errorf("channel_not_found")</span>
        case "already_archived":<span class="cov0" title="0">
                m.ArchiveConversationError = fmt.Errorf("already_archived")</span>
        case "":<span class="cov0" title="0">
                m.ArchiveConversationError = nil</span>
        default:<span class="cov0" title="0">
                m.ArchiveConversationError = fmt.Errorf("%s", errorType)</span>
        }
}

func (m *MockSlackAPI) GetArchivedChannels() []string <span class="cov0" title="0">{
        return m.ArchivedChannels
}</span>

func (m *MockSlackAPI) ClearArchivedChannels() <span class="cov0" title="0">{
        m.ArchivedChannels = []string{}
}</span>

func (m *MockSlackAPI) SetJoinConversationError(errorType string) <span class="cov0" title="0">{
        switch errorType </span>{
        case "missing_scope":<span class="cov0" title="0">
                m.JoinConversationError = fmt.Errorf("missing_scope")</span>
        case "channel_not_found":<span class="cov0" title="0">
                m.JoinConversationError = fmt.Errorf("channel_not_found")</span>
        case "already_in_channel":<span class="cov0" title="0">
                m.JoinConversationError = fmt.Errorf("already_in_channel")</span>
        case "":<span class="cov0" title="0">
                m.JoinConversationError = nil</span>
        default:<span class="cov0" title="0">
                m.JoinConversationError = fmt.Errorf("%s", errorType)</span>
        }
}

func (m *MockSlackAPI) GetJoinedChannels() []string <span class="cov0" title="0">{
        return m.JoinedChannels
}</span>

func (m *MockSlackAPI) ClearJoinedChannels() <span class="cov0" title="0">{
        m.JoinedChannels = []string{}
}</span>

func (m *MockSlackAPI) AddUser(id, name, realName string) <span class="cov8" title="1">{
        user := slack.User{
                ID:       id,
                Name:     name,
                RealName: realName,
                Profile: slack.UserProfile{
                        DisplayName: realName,
                },
        }
        m.Users = append(m.Users, user)
}</span>

func (m *MockSlackAPI) SetGetUsersError(errorType string) <span class="cov8" title="1">{
        switch errorType </span>{
        case "missing_scope":<span class="cov8" title="1">
                m.GetUsersError = fmt.Errorf("missing_scope")</span>
        case "":<span class="cov0" title="0">
                m.GetUsersError = nil</span>
        default:<span class="cov8" title="1">
                m.GetUsersError = fmt.Errorf("%s", errorType)</span>
        }
}

// Additional helper methods for archive testing

// MockMessage represents a message in conversation history for testing
type MockHistoryMessage struct {
        Timestamp string
        User      string
        Text      string
        SubType   string
}

// SetChannelHistory sets up mock conversation history for a channel
func (m *MockSlackAPI) SetChannelHistory(channelID string, messages []MockHistoryMessage) <span class="cov8" title="1">{
        if m.ConversationHistory == nil </span><span class="cov0" title="0">{
                m.ConversationHistory = make(map[string][]slack.Message)
        }</span>

        <span class="cov8" title="1">slackMessages := make([]slack.Message, len(messages))
        for i, msg := range messages </span><span class="cov8" title="1">{
                slackMessages[i] = slack.Message{
                        Msg: slack.Msg{
                                Type:      "message",
                                Text:      msg.Text,
                                User:      msg.User,
                                Timestamp: msg.Timestamp,
                                SubType:   msg.SubType,
                        },
                }
        }</span>

        <span class="cov8" title="1">m.ConversationHistory[channelID] = slackMessages</span>
}

// SetBotUserID sets the bot user ID for testing
func (m *MockSlackAPI) SetBotUserID(userID string) <span class="cov8" title="1">{
        if m.AuthTestResponse == nil </span><span class="cov0" title="0">{
                m.AuthTestResponse = &amp;slack.AuthTestResponse{}
        }</span>
        <span class="cov8" title="1">m.AuthTestResponse.UserID = userID</span>
}

// SetGetConversationHistoryError sets an error for a specific channel's history
func (m *MockSlackAPI) SetGetConversationHistoryError(channelID string, hasError bool) <span class="cov8" title="1">{
        if m.ConversationHistoryErrors == nil </span><span class="cov0" title="0">{
                m.ConversationHistoryErrors = make(map[string]error)
        }</span>

        <span class="cov8" title="1">if hasError </span><span class="cov8" title="1">{
                m.ConversationHistoryErrors[channelID] = fmt.Errorf("failed to get conversation history")
        }</span> else<span class="cov0" title="0"> {
                delete(m.ConversationHistoryErrors, channelID)
        }</span>
}

// SetJoinConversationErrorForChannel sets an error for joining a specific channel
func (m *MockSlackAPI) SetJoinConversationErrorForChannel(channelID string, hasError bool) <span class="cov8" title="1">{
        if m.JoinConversationErrors == nil </span><span class="cov0" title="0">{
                m.JoinConversationErrors = make(map[string]error)
        }</span>

        <span class="cov8" title="1">if hasError </span><span class="cov8" title="1">{
                m.JoinConversationErrors[channelID] = fmt.Errorf("failed to join conversation")
        }</span> else<span class="cov0" title="0"> {
                delete(m.JoinConversationErrors, channelID)
        }</span>
}

// SetArchiveConversationErrorWithMessage sets a specific error message for archiving a channel
func (m *MockSlackAPI) SetArchiveConversationErrorWithMessage(channelID string, hasError bool, errorType string) <span class="cov8" title="1">{
        if m.ArchiveConversationErrors == nil </span><span class="cov0" title="0">{
                m.ArchiveConversationErrors = make(map[string]error)
        }</span>

        <span class="cov8" title="1">if hasError </span><span class="cov8" title="1">{
                switch errorType </span>{
                case "missing_scope":<span class="cov8" title="1">
                        m.ArchiveConversationErrors[channelID] = fmt.Errorf("missing_scope")</span>
                case "channel_not_found":<span class="cov0" title="0">
                        m.ArchiveConversationErrors[channelID] = fmt.Errorf("channel_not_found")</span>
                case "already_archived":<span class="cov8" title="1">
                        m.ArchiveConversationErrors[channelID] = fmt.Errorf("already_archived")</span>
                default:<span class="cov0" title="0">
                        m.ArchiveConversationErrors[channelID] = fmt.Errorf("%s", errorType)</span>
                }
        } else<span class="cov0" title="0"> {
                delete(m.ArchiveConversationErrors, channelID)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package slack

import (
        "fmt"
        "regexp"
        "strings"
)

// ValidateSlackToken performs basic validation on Slack bot tokens.
func ValidateSlackToken(token string) error <span class="cov8" title="1">{
        if token == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("token cannot be empty")
        }</span>

        // Allow test tokens for testing purposes
        <span class="cov8" title="1">if strings.HasPrefix(token, "MOCK-") || strings.Contains(token, "TESTING-ONLY") </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Slack bot tokens should start with "xoxb-"
        <span class="cov8" title="1">if !strings.HasPrefix(token, "xoxb-") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid token format: bot tokens must start with 'xoxb-'")
        }</span>

        // Basic format validation (xoxb-XXXXXXXXXXXX-XXXXXXXXXXXXX-XXXXXXXXXXXXXXXXXXXXXXXX)
        <span class="cov8" title="1">botTokenPattern := regexp.MustCompile(`^xoxb-\d+-\d+-[a-zA-Z0-9]+$`)
        if !botTokenPattern.MatchString(token) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid token format: token does not match expected Slack bot token pattern")
        }</span>

        // Check for minimum length (Slack tokens are typically much longer)
        <span class="cov0" title="0">if len(token) &lt; 50 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid token: token appears too short")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SanitizeForLogging removes sensitive information from strings for safe logging.
func SanitizeForLogging(input string) string <span class="cov8" title="1">{
        // Replace any token-like patterns with [REDACTED]
        tokenPattern := regexp.MustCompile(`xoxb-[a-zA-Z0-9-]+`)
        result := tokenPattern.ReplaceAllString(input, "[REDACTED]")

        // Also redact test tokens
        testTokenPattern := regexp.MustCompile(`MOCK-[A-Z0-9-]+`)
        result = testTokenPattern.ReplaceAllString(result, "[REDACTED]")

        return result
}</span>

// ValidateChannelName performs basic validation on channel names.
func ValidateChannelName(channelName string) error <span class="cov8" title="1">{
        if channelName == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("channel name cannot be empty")
        }</span>

        // Remove # prefix for validation
        <span class="cov8" title="1">name := strings.TrimPrefix(channelName, "#")

        // Check if name is empty after removing prefix
        if name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("channel name cannot be empty")
        }</span>

        // Basic channel name validation (alphanumeric, hyphens, underscores)
        <span class="cov8" title="1">channelPattern := regexp.MustCompile(`^[a-z0-9_-]+$`)
        if !channelPattern.MatchString(name) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid channel name: must contain only lowercase letters, numbers, hyphens, and underscores")
        }</span>

        <span class="cov8" title="1">if len(name) &gt; 80 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid channel name: too long (max 80 characters)")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
