
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">slack-buddy-ai/cmd/channels.go (48.3%)</option>
				
				<option value="file1">slack-buddy-ai/cmd/root.go (75.0%)</option>
				
				<option value="file2">slack-buddy-ai/main.go (0.0%)</option>
				
				<option value="file3">slack-buddy-ai/pkg/slack/client.go (96.3%)</option>
				
				<option value="file4">slack-buddy-ai/pkg/slack/interface.go (100.0%)</option>
				
				<option value="file5">slack-buddy-ai/pkg/slack/mock.go (100.0%)</option>
				
				<option value="file6">slack-buddy-ai/pkg/slack/security.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "slack-buddy-ai/pkg/slack"
        "time"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var channelsCmd = &amp;cobra.Command{
        Use:   "channels",
        Short: "Manage channels in your Slack workspace",
        Long:  `Commands for managing and monitoring channels in your Slack workspace.`,
}

var detectCmd = &amp;cobra.Command{
        Use:   "detect",
        Short: "Detect new channels created in a time period",
        Long:  `Detect new channels created during a specified time period and optionally announce them to another channel.`,
        RunE:  runDetect,
}

var (
        since      string
        announceTo string
)

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(channelsCmd)
        channelsCmd.AddCommand(detectCmd)

        detectCmd.Flags().StringVar(&amp;since, "since", "24h", "Time period to look back (e.g., 24h, 7d, 1w)")
        detectCmd.Flags().StringVar(&amp;announceTo, "announce-to", "", "Channel to announce new channels to (e.g., #general)")
}</span>

func runDetect(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        token := viper.GetString("token")
        if token == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("slack token is required. Set SLACK_TOKEN environment variable or use --token flag")
        }</span>

        <span class="cov8" title="1">duration, err := time.ParseDuration(since)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid time format '%s': %v", since, err)
        }</span>

        <span class="cov8" title="1">cutoffTime := time.Now().Add(-duration)

        client, err := slack.NewClient(token)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create Slack client: %v", err)
        }</span>

        <span class="cov0" title="0">newChannels, err := client.GetNewChannels(cutoffTime)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get new channels: %v", err)
        }</span>

        <span class="cov0" title="0">if len(newChannels) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("No new channels found since %s\n", cutoffTime.Format("2006-01-02 15:04:05"))
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("Found %d new channel(s) since %s:\n", len(newChannels), cutoffTime.Format("2006-01-02 15:04:05"))
        for _, channel := range newChannels </span><span class="cov0" title="0">{
                fmt.Printf("  #%s (created: %s)\n", channel.Name, channel.Created.Format("2006-01-02 15:04:05"))
        }</span>

        <span class="cov0" title="0">if announceTo != "" </span><span class="cov0" title="0">{
                message := client.FormatNewChannelAnnouncement(newChannels, cutoffTime)
                if err := client.PostMessage(announceTo, message); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to post announcement to %s: %v", announceTo, err)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Announcement posted to %s\n", announceTo)</span>
        }

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var rootCmd = &amp;cobra.Command{
        Use:   "slack-buddy",
        Short: "A CLI tool to help manage Slack workspaces",
        Long:  `Slack Buddy is a CLI tool that helps make Slack workspaces more useful and tidy.`,
}

func Execute() <span class="cov8" title="1">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
}

func init() <span class="cov8" title="1">{
        cobra.OnInitialize(initConfig)
        rootCmd.PersistentFlags().String("token", "", "Slack bot token (can also be set via SLACK_TOKEN env var)")
        viper.BindPFlag("token", rootCmd.PersistentFlags().Lookup("token"))
}</span>

func initConfig() <span class="cov8" title="1">{
        viper.SetEnvPrefix("SLACK")
        viper.AutomaticEnv()
}</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "slack-buddy-ai/cmd"
)

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</pre>
		
		<pre class="file" id="file3" style="display: none">package slack

import (
        "fmt"
        "strings"
        "time"

        "github.com/slack-go/slack"
)

type Client struct {
        api SlackAPI
}

type Channel struct {
        ID      string
        Name    string
        Created time.Time
        Purpose string
}

func NewClient(token string) (*Client, error) <span class="cov8" title="1">{
        // Validate token format before using it
        if err := ValidateSlackToken(token); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid token: %v", err)
        }</span>

        <span class="cov8" title="1">api := NewRealSlackAPI(token)
        
        auth, err := api.AuthTest()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("authentication failed: %v", SanitizeForLogging(err.Error()))
        }</span>

        <span class="cov0" title="0">fmt.Printf("Connected as: %s (team: %s)\n", auth.User, auth.Team)
        return &amp;Client{api: api}, nil</span>
}

// NewClientWithAPI creates a client with a custom API implementation (for testing)
func NewClientWithAPI(api SlackAPI) (*Client, error) <span class="cov8" title="1">{
        if api == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("API cannot be nil")
        }</span>
        
        <span class="cov8" title="1">auth, err := api.AuthTest()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("authentication failed: %v", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("Connected as: %s (team: %s)\n", auth.User, auth.Team)
        return &amp;Client{api: api}, nil</span>
}

func (c *Client) GetNewChannels(since time.Time) ([]Channel, error) <span class="cov8" title="1">{
        channels, _, err := c.api.GetConversations(&amp;slack.GetConversationsParameters{
                Types: []string{"public_channel", "private_channel"},
                Limit: 1000,
        })
        if err != nil </span><span class="cov8" title="1">{
                errStr := err.Error()
                if strings.Contains(errStr, "missing_scope") </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("missing required permissions. Your bot needs these OAuth scopes:\n  - channels:read (to list public channels)\n  - groups:read (to list private channels)\n\nPlease add these scopes in your Slack app settings at https://api.slack.com/apps")
                }</span>
                <span class="cov8" title="1">if strings.Contains(errStr, "invalid_auth") </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid token. Please check your SLACK_TOKEN")
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("failed to get conversations: %v", err)</span>
        }

        <span class="cov8" title="1">var newChannels []Channel
        for _, ch := range channels </span><span class="cov8" title="1">{
                created := time.Unix(int64(ch.Created), 0)
                if created.After(since) </span><span class="cov8" title="1">{
                        newChannels = append(newChannels, Channel{
                                ID:      ch.ID,
                                Name:    ch.Name,
                                Created: created,
                                Purpose: ch.Purpose.Value,
                        })
                }</span>
        }

        <span class="cov8" title="1">return newChannels, nil</span>
}

func (c *Client) FormatNewChannelAnnouncement(channels []Channel, since time.Time) string <span class="cov8" title="1">{
        var builder strings.Builder
        
        if len(channels) == 1 </span><span class="cov8" title="1">{
                builder.WriteString("🆕 New channel alert!")
        }</span> else<span class="cov8" title="1"> {
                builder.WriteString(fmt.Sprintf("🆕 %d new channels created!", len(channels)))
        }</span>
        
        <span class="cov8" title="1">builder.WriteString(fmt.Sprintf("\n\nChannels created since %s:\n", since.Format("2006-01-02 15:04")))
        
        for _, ch := range channels </span><span class="cov8" title="1">{
                builder.WriteString(fmt.Sprintf("• &lt;#%s&gt; - created %s", ch.ID, ch.Created.Format("2006-01-02 15:04")))
                if ch.Purpose != "" </span><span class="cov8" title="1">{
                        builder.WriteString(fmt.Sprintf("\n  Purpose: %s", ch.Purpose))
                }</span>
                <span class="cov8" title="1">builder.WriteString("\n")</span>
        }
        
        <span class="cov8" title="1">return builder.String()</span>
}

func (c *Client) PostMessage(channel, message string) error <span class="cov8" title="1">{
        // Validate channel name format
        if err := ValidateChannelName(channel); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid channel name '%s': %v", channel, err)
        }</span>

        <span class="cov8" title="1">channelID := strings.TrimPrefix(channel, "#")
        
        _, _, err := c.api.PostMessage(channelID, slack.MsgOptionText(message, false))
        if err != nil </span><span class="cov8" title="1">{
                errStr := err.Error()
                if strings.Contains(errStr, "missing_scope") </span><span class="cov8" title="1">{
                        return fmt.Errorf("missing required permission to post messages. Your bot needs the 'chat:write' OAuth scope.\nPlease add this scope in your Slack app settings at https://api.slack.com/apps")
                }</span>
                <span class="cov8" title="1">if strings.Contains(errStr, "channel_not_found") </span><span class="cov8" title="1">{
                        return fmt.Errorf("channel '%s' not found. Make sure the bot is added to the channel", channel)
                }</span>
                <span class="cov8" title="1">if strings.Contains(errStr, "not_in_channel") </span><span class="cov8" title="1">{
                        return fmt.Errorf("bot is not a member of channel '%s'. Please add the bot to the channel", channel)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("failed to post message to %s: %v", channel, err)</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package slack

import (
        "github.com/slack-go/slack"
)

// SlackAPI defines the interface for Slack API operations
type SlackAPI interface {
        AuthTest() (*slack.AuthTestResponse, error)
        GetConversations(params *slack.GetConversationsParameters) ([]slack.Channel, string, error)
        PostMessage(channelID string, options ...slack.MsgOption) (string, string, error)
}

// RealSlackAPI wraps the actual Slack API client
type RealSlackAPI struct {
        client *slack.Client
}

// NewRealSlackAPI creates a new real Slack API wrapper
func NewRealSlackAPI(token string) *RealSlackAPI <span class="cov8" title="1">{
        return &amp;RealSlackAPI{
                client: slack.New(token),
        }
}</span>

func (r *RealSlackAPI) AuthTest() (*slack.AuthTestResponse, error) <span class="cov8" title="1">{
        return r.client.AuthTest()
}</span>

func (r *RealSlackAPI) GetConversations(params *slack.GetConversationsParameters) ([]slack.Channel, string, error) <span class="cov8" title="1">{
        return r.client.GetConversations(params)
}</span>

func (r *RealSlackAPI) PostMessage(channelID string, options ...slack.MsgOption) (string, string, error) <span class="cov8" title="1">{
        return r.client.PostMessage(channelID, options...)
}</pre>
		
		<pre class="file" id="file5" style="display: none">package slack

import (
        "fmt"
        "time"

        "github.com/slack-go/slack"
)

// MockSlackAPI implements SlackAPI for testing
type MockSlackAPI struct {
        AuthTestResponse    *slack.AuthTestResponse
        AuthTestError       error
        Channels           []slack.Channel
        GetConversationsError error
        PostMessageError    error
        PostedMessages      []MockMessage
}

type MockMessage struct {
        ChannelID string
        Text      string
}

// NewMockSlackAPI creates a new mock Slack API
func NewMockSlackAPI() *MockSlackAPI <span class="cov8" title="1">{
        return &amp;MockSlackAPI{
                AuthTestResponse: &amp;slack.AuthTestResponse{
                        User: "test-bot",
                        Team: "Test Team",
                },
                Channels:       []slack.Channel{},
                PostedMessages: []MockMessage{},
        }
}</span>

func (m *MockSlackAPI) AuthTest() (*slack.AuthTestResponse, error) <span class="cov8" title="1">{
        if m.AuthTestError != nil </span><span class="cov8" title="1">{
                return nil, m.AuthTestError
        }</span>
        <span class="cov8" title="1">return m.AuthTestResponse, nil</span>
}

func (m *MockSlackAPI) GetConversations(params *slack.GetConversationsParameters) ([]slack.Channel, string, error) <span class="cov8" title="1">{
        if m.GetConversationsError != nil </span><span class="cov8" title="1">{
                return nil, "", m.GetConversationsError
        }</span>
        <span class="cov8" title="1">return m.Channels, "", nil</span>
}

func (m *MockSlackAPI) PostMessage(channelID string, options ...slack.MsgOption) (string, string, error) <span class="cov8" title="1">{
        if m.PostMessageError != nil </span><span class="cov8" title="1">{
                return "", "", m.PostMessageError
        }</span>

        // For testing purposes, we'll just record that a message was posted
        message := MockMessage{
        <span class="cov8" title="1">        ChannelID: channelID,
                Text:      "mock-message-text", // Simplified for testing
        }
        m.PostedMessages = append(m.PostedMessages, message)

        return "mock-channel-id", "mock-timestamp", nil
}
</span>
// Helper methods for testing

func (m *MockSlackAPI) AddChannel(id, name string, created time.Time, purpose string) {
        channel := slack.Channel{
                GroupConversation: slack.GroupConversation{
                        Conversation: slack.Conversation{
                                ID:      id,
                                Created: slack.JSONTime(created.Unix()),
                        },
                        Name: name,
                        Purpose: slack.Purpose{
                                Value: purpose,
                        },
                },
        }
        m.Channels = append(m.Channels, channel)
}

</span>func (m *MockSlackAPI) SetAuthError(hasError bool) {
        if hasError {
                m.AuthTestE</span><span class="cov8" title="1">rror = fmt.Errorf("authentication failed")
        } else {
                </span>m.Aut<span class="cov8" title="1">hTestError = nil
        }
}
</span>
func (m *MockSlackAPI) SetGetConversationsError(hasError bool) {
        if hasError {
                m.GetConver</span><span class="cov8" title="1">sationsError = fmt.Errorf("failed to get conversations")
        } else {
                </span>m.Get<span class="cov8" title="1">ConversationsError = nil
        }
}
</span>
func (m *MockSlackAPI) SetPostMessageError(errorType string) {
        switch errorType {
        case "missing_sco</span>pe":
                m.PostMessageError =<span class="cov8" title="1"> fmt.Errorf("missing_scope")
        case "channel_not_found":
</span>                m.PostMessageError = fmt<span class="cov8" title="1">.Errorf("channel_not_found")
        case "not_in_channel":
</span>                m.PostMessageError = <span class="cov8" title="1">fmt.Errorf("not_in_channel")
        case "generic_error":
</span>                m.PostMessageError =<span class="cov8" title="1"> fmt.Errorf("generic error")
        case "":
</span>                m.PostM<span class="cov8" title="1">essageError = nil
        default:
</span>                m.PostM<span class="cov8" title="1">essageError = fmt.Errorf("%s", errorType)
        }
</span>}

// Additional helper methods for specific error types
func (m *MockSlackAPI) SetMissingScopeError(hasError bool) {
        if hasError {
                m.GetConver</span><span class="cov8" title="1">sationsError = fmt.Errorf("missing_scope")
        } else {
                </span>m.Get<span class="cov8" title="1">ConversationsError = nil
        }
}
</span>
func (m *MockSlackAPI) SetInvalidAuthError(hasError bool) {
        if hasError {
                m.GetConver</span><span class="cov8" title="1">sationsError = fmt.Errorf("invalid_auth")
        } else {
                </span>m.Get<span class="cov8" title="1">ConversationsError = nil
        }
}
</span>
func (m *MockSlackAPI) GetPostedMessages() []MockMessage {
        return m.PostedMessages
}

</span>func (m *MockSlackAPI) ClearPostedMessages() {
        m.PostedMessages = []MockMessage{}
}

</span>// Simulate specific error types
func (m *MockSlackAPI) SimulateMissingScopeError() {
        m.SetMissingScopeError(true)
}

</span>func (m *MockSlackAPI) SimulateInvalidAuthError() {
        m.SetAuthError(true)
}

</span>func (m *MockSlackAPI) SimulateChannelNotFoundError() {
        m.SetPostMessageError("channel_not_found")
}

</span>func (m *MockSlackAPI) SimulateNotInChannelError() {
        m.SetPostMessageError("not_in_channel")
}</pre>
		
		<pre class="file" id="file6" style="display: none">package slack

import (
        "fmt"
        "regexp"
        "strings"
)

// ValidateSlackToken performs basic validation on Slack bot tokens
func ValidateSlackToken(token string) error <span class="cov8" title="1">{
        if token == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("token cannot be empty")
        }</span>

        // Slack bot tokens should start with "xoxb-"
        <span class="cov8" title="1">if !strings.HasPrefix(token, "xoxb-") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid token format: bot tokens must start with 'xoxb-'")
        }</span>

        // Basic format validation (xoxb-XXXXXXXXXXXX-XXXXXXXXXXXXX-XXXXXXXXXXXXXXXXXXXXXXXX)
        <span class="cov8" title="1">botTokenPattern := regexp.MustCompile(`^xoxb-\d+-\d+-[a-zA-Z0-9]+$`)
        if !botTokenPattern.MatchString(token) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid token format: token does not match expected Slack bot token pattern")
        }</span>

        // Check for minimum length (Slack tokens are typically much longer)
        <span class="cov8" title="1">if len(token) &lt; 50 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid token: token appears too short")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SanitizeForLogging removes sensitive information from strings for safe logging
func SanitizeForLogging(input string) string <span class="cov8" title="1">{
        // Replace any token-like patterns with [REDACTED]
        tokenPattern := regexp.MustCompile(`xoxb-[a-zA-Z0-9-]+`)
        return tokenPattern.ReplaceAllString(input, "[REDACTED]")
}</span>

// ValidateChannelName performs basic validation on channel names
func ValidateChannelName(channelName string) error <span class="cov8" title="1">{
        if channelName == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("channel name cannot be empty")
        }</span>

        // Remove # prefix for validation
        <span class="cov8" title="1">name := strings.TrimPrefix(channelName, "#")
        
        // Check if name is empty after removing prefix
        if name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("channel name cannot be empty")
        }</span>
        
        // Basic channel name validation (alphanumeric, hyphens, underscores)
        <span class="cov8" title="1">channelPattern := regexp.MustCompile(`^[a-z0-9_-]+$`)
        if !channelPattern.MatchString(name) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid channel name: must contain only lowercase letters, numbers, hyphens, and underscores")
        }</span>

        <span class="cov8" title="1">if len(name) &gt; 80 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid channel name: too long (max 80 characters)")
        }</span>

        <span class="cov8" title="1">return nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
