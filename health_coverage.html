
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/astrostl/slack-buddy-ai/cmd/channels.go (5.6%)</option>
				
				<option value="file1">github.com/astrostl/slack-buddy-ai/cmd/health.go (32.8%)</option>
				
				<option value="file2">github.com/astrostl/slack-buddy-ai/cmd/root.go (42.9%)</option>
				
				<option value="file3">github.com/astrostl/slack-buddy-ai/cmd/version.go (16.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/astrostl/slack-buddy-ai/pkg/logger"
        "github.com/astrostl/slack-buddy-ai/pkg/slack"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var channelsCmd = &amp;cobra.Command{
        Use:          "channels",
        Short:        "Manage channels in your Slack workspace",
        Long:         `Commands for managing and monitoring channels in your Slack workspace.`,
        SilenceUsage: true, // Don't show usage on errors
}

var detectCmd = &amp;cobra.Command{
        Use:   "detect",
        Short: "Detect new channels created in a time period",
        Long: `Detect new channels created during a specified time period and optionally announce them to another channel.

Use --dry-run to preview what would be announced without actually posting messages.`,
        SilenceUsage: true, // Don't show usage on errors
        RunE:         runDetect,
}

var archiveCmd = &amp;cobra.Command{
        Use:   "archive",
        Short: "Manage inactive channel archival with warnings",
        Long: `Detect inactive channels, warn them about upcoming archival, and archive channels that remain inactive after the grace period.

This command operates in a stateless manner by using channel message history to determine activity and warning status.
Warning messages are used as state markers to track the grace period.

The bot will automatically join public channels to send warning messages. Required OAuth scopes:
- channels:read (to list channels) - REQUIRED
- channels:join (to join public channels) - REQUIRED  
- chat:write (to post warnings) - REQUIRED
- channels:manage (to archive channels) - REQUIRED

Use --dry-run to preview what actions would be taken without actually warning or archiving channels.

NOTE: Currently using SECONDS for testing (will be changed back to days later).`,
        SilenceUsage: true, // Don't show usage on errors
        RunE:         runArchive,
}

var (
        since           string
        announceTo      string
        dryRun          bool
        warnSeconds     int
        archiveSeconds  int
        excludeChannels string
        excludePrefixes string
)

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(channelsCmd)
        channelsCmd.AddCommand(detectCmd)
        channelsCmd.AddCommand(archiveCmd)

        detectCmd.Flags().StringVar(&amp;since, "since", "1", "Number of days to look back (e.g., 1, 7, 30)")
        detectCmd.Flags().StringVar(&amp;announceTo, "announce-to", "", "Channel to announce new channels to (e.g., #general)")
        detectCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show what would be announced without actually posting messages")

        archiveCmd.Flags().IntVar(&amp;warnSeconds, "warn-seconds", 300, "Number of seconds of inactivity before warning (default: 300 = 5 minutes)")
        archiveCmd.Flags().IntVar(&amp;archiveSeconds, "archive-seconds", 60, "Number of seconds after warning (with no new activity) before archiving (default: 60 = 1 minute)")
        archiveCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Preview actions without actually warning or archiving channels")
        archiveCmd.Flags().StringVar(&amp;excludeChannels, "exclude-channels", "", "Comma-separated list of channel names to exclude (with or without # prefix, e.g., 'general,random,#important')")
        archiveCmd.Flags().StringVar(&amp;excludePrefixes, "exclude-prefixes", "", "Comma-separated list of channel prefixes to exclude (with or without # prefix, e.g., 'prod-,#temp-,admin')")
}</span>

func runDetect(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        token := viper.GetString("token")
        if token == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("slack token is required. Set SLACK_TOKEN environment variable or use --token flag")
        }</span>

        <span class="cov0" title="0">days, err := strconv.ParseFloat(since, 64)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid days format '%s': must be a number (e.g., 1, 7, 30)", since)
        }</span>

        <span class="cov0" title="0">if days &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("days must be positive, got %g", days)
        }</span>

        <span class="cov0" title="0">duration := time.Duration(days*24) * time.Hour
        cutoffTime := time.Now().Add(-duration)

        client, err := slack.NewClient(token)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Slack client: %w", err)
        }</span>

        <span class="cov0" title="0">return runDetectWithClient(client, cutoffTime, announceTo, dryRun)</span>
}

func runDetectWithClient(client *slack.Client, cutoffTime time.Time, announceChannel string, isDryRun bool) error <span class="cov0" title="0">{
        newChannels, err := client.GetNewChannels(cutoffTime)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get new channels: %w", err)
        }</span>

        <span class="cov0" title="0">if len(newChannels) == 0 </span><span class="cov0" title="0">{
                logger.WithFields(logger.LogFields{
                        "since": cutoffTime.Format("2006-01-02 15:04:05"),
                }).Info("No new channels found")
                return nil
        }</span>

        <span class="cov0" title="0">logger.WithFields(logger.LogFields{
                "count": len(newChannels),
                "since": cutoffTime.Format("2006-01-02 15:04:05"),
        }).Info("Found new channels")

        for _, channel := range newChannels </span><span class="cov0" title="0">{
                logger.WithFields(logger.LogFields{
                        "channel": channel.Name,
                        "created": channel.Created.Format("2006-01-02 15:04:05"),
                }).Info("New channel detected")
                fmt.Printf("  #%s (created: %s)\n", channel.Name, channel.Created.Format("2006-01-02 15:04:05"))
        }</span>

        // Add summary list at the end for easy copying
        <span class="cov0" title="0">if len(newChannels) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println()
                fmt.Printf("New channels found (%d):\n", len(newChannels))
                for _, channel := range newChannels </span><span class="cov0" title="0">{
                        fmt.Printf("  #%s\n", channel.Name)
                }</span>
        }

        <span class="cov0" title="0">if announceChannel != "" </span><span class="cov0" title="0">{
                message := client.FormatNewChannelAnnouncement(newChannels, cutoffTime)

                if isDryRun </span><span class="cov0" title="0">{
                        fmt.Printf("\n--- DRY RUN ---\n")
                        fmt.Printf("Would announce to channel: %s\n", announceChannel)
                        fmt.Printf("Message content:\n%s\n", message)
                        fmt.Printf("--- END DRY RUN ---\n")
                        logger.WithField("channel", announceChannel).Info("Dry run: announcement preview shown")
                }</span> else<span class="cov0" title="0"> {
                        if err := client.PostMessage(announceChannel, message); err != nil </span><span class="cov0" title="0">{
                                logger.WithFields(logger.LogFields{
                                        "channel": announceChannel,
                                        "error":   err.Error(),
                                }).Error("Failed to post announcement")
                                return fmt.Errorf("failed to post announcement to %s: %w", announceChannel, err)
                        }</span>
                        <span class="cov0" title="0">logger.WithField("channel", announceChannel).Info("Announcement posted successfully")
                        fmt.Printf("Announcement posted to %s\n", announceChannel)</span>
                }
        } else<span class="cov0" title="0"> if isDryRun </span><span class="cov0" title="0">{
                // Show what announcement message would look like even without a target channel
                message := client.FormatNewChannelAnnouncement(newChannels, cutoffTime)
                fmt.Printf("\n--- DRY RUN ---\n")
                fmt.Printf("Announcement message preview (use --announce-to to specify target):\n%s\n", message)
                fmt.Printf("--- END DRY RUN ---\n")
                logger.Info("Dry run: message preview shown without target channel")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func runArchive(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        token := viper.GetString("token")
        if token == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("slack token is required. Set SLACK_TOKEN environment variable or use --token flag")
        }</span>

        <span class="cov0" title="0">if warnSeconds &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("warn-seconds must be positive, got %d", warnSeconds)
        }</span>

        <span class="cov0" title="0">if archiveSeconds &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("archive-seconds must be positive, got %d", archiveSeconds)
        }</span>

        <span class="cov0" title="0">client, err := slack.NewClient(token)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Slack client: %w", err)
        }</span>

        <span class="cov0" title="0">return runArchiveWithClient(client, warnSeconds, archiveSeconds, dryRun, excludeChannels, excludePrefixes)</span>
}

func runArchiveWithClient(client *slack.Client, warnSeconds, archiveSeconds int, isDryRun bool, excludeChannels, excludePrefixes string) error <span class="cov0" title="0">{
        logger.WithFields(logger.LogFields{
                "warn_seconds":    warnSeconds,
                "archive_seconds": archiveSeconds,
                "dry_run":         isDryRun,
        }).Info("Starting inactive channel analysis")

        fmt.Printf("🔍 Analyzing inactive channels...\n\n")

        // Get user map for name resolution
        fmt.Printf("📞 API Call 1: Getting user list for name resolution...\n")
        userMap, err := client.GetUserMap()
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "rate_limited") || strings.Contains(err.Error(), "rate limit") </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️  Slack API rate limit exceeded on user list.\n")
                        fmt.Printf("   The system should have done backoff.\n")
                        return fmt.Errorf("rate limited by Slack API")
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "missing_scope") || strings.Contains(err.Error(), "users:read") </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Missing required OAuth scope 'users:read'\n")
                        fmt.Printf("   This scope is needed to resolve user names for message authors.\n")
                        fmt.Printf("   Add 'users:read' scope in your Slack app settings at https://api.slack.com/apps\n")
                        return fmt.Errorf("missing required OAuth scope 'users:read'")
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get users: %w", err)</span>
        }
        <span class="cov0" title="0">fmt.Printf("✅ Got %d users from API\n\n", len(userMap))

        // Parse exclusion lists
        var excludeChannelsList []string
        var excludePrefixesList []string

        if excludeChannels != "" </span><span class="cov0" title="0">{
                for _, channel := range strings.Split(excludeChannels, ",") </span><span class="cov0" title="0">{
                        channel = strings.TrimSpace(channel)
                        // Remove # prefix if present
                        if strings.HasPrefix(channel, "#") </span><span class="cov0" title="0">{
                                channel = channel[1:]
                        }</span>
                        <span class="cov0" title="0">if channel != "" </span><span class="cov0" title="0">{
                                excludeChannelsList = append(excludeChannelsList, channel)
                        }</span>
                }
        }

        <span class="cov0" title="0">if excludePrefixes != "" </span><span class="cov0" title="0">{
                for _, prefix := range strings.Split(excludePrefixes, ",") </span><span class="cov0" title="0">{
                        prefix = strings.TrimSpace(prefix)
                        // Remove # prefix if present
                        if strings.HasPrefix(prefix, "#") </span><span class="cov0" title="0">{
                                prefix = prefix[1:]
                        }</span>
                        <span class="cov0" title="0">if prefix != "" </span><span class="cov0" title="0">{
                                excludePrefixesList = append(excludePrefixesList, prefix)
                        }</span>
                }
        }

        // Show exclusion info if any are specified
        <span class="cov0" title="0">if len(excludeChannelsList) &gt; 0 || len(excludePrefixesList) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("📋 Channel exclusions configured:\n")
                if len(excludeChannelsList) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("   Excluded channels: %s\n", strings.Join(excludeChannelsList, ", "))
                }</span>
                <span class="cov0" title="0">if len(excludePrefixesList) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("   Excluded prefixes: %s\n", strings.Join(excludePrefixesList, ", "))
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov0" title="0">toWarn, toArchive, err := client.GetInactiveChannelsWithDetailsAndExclusions(warnSeconds, archiveSeconds, userMap, excludeChannelsList, excludePrefixesList)
        if err != nil </span><span class="cov0" title="0">{
                // Check if this is a rate limit error and provide helpful guidance
                if strings.Contains(err.Error(), "rate_limited") || strings.Contains(err.Error(), "rate limit") </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️  Slack API rate limit exceeded.\n")
                        fmt.Printf("   The analysis was stopped to respect API limits.\n")
                        fmt.Printf("   Please wait a few minutes before running the command again.\n")
                        fmt.Printf("   \n")
                        fmt.Printf("   Tip: Consider running with longer time periods (e.g. --warn-seconds=3600) to reduce API calls.\n")
                        return fmt.Errorf("rate limited by Slack API")
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to analyze inactive channels: %w", err)</span>
        }

        // Report findings
        <span class="cov0" title="0">fmt.Printf("Inactive Channel Analysis Results:\n")
        fmt.Printf("  Channels to warn: %d\n", len(toWarn))
        fmt.Printf("  Channels to archive: %d\n", len(toArchive))
        fmt.Println()

        // Process warnings
        if len(toWarn) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Channels to warn about inactivity:\n")
                for _, channel := range toWarn </span><span class="cov0" title="0">{
                        fmt.Printf("  #%s (inactive since: %s, members: %d)\n",
                                channel.Name,
                                channel.LastActivity.Format("2006-01-02 15:04:05"),
                                channel.MemberCount)

                        // Show last message details if available
                        if channel.LastMessage != nil </span><span class="cov0" title="0">{
                                messageText := channel.LastMessage.Text
                                if len(messageText) &gt; 60 </span><span class="cov0" title="0">{
                                        messageText = messageText[:57] + "..."
                                }</span>
                                <span class="cov0" title="0">messageText = strings.ReplaceAll(messageText, "\n", " ")

                                authorName := channel.LastMessage.UserName
                                if authorName == "" </span><span class="cov0" title="0">{
                                        authorName = channel.LastMessage.User
                                }</span>

                                <span class="cov0" title="0">botIndicator := ""
                                if channel.LastMessage.IsBot </span><span class="cov0" title="0">{
                                        botIndicator = " (bot)"
                                }</span>

                                <span class="cov0" title="0">fmt.Printf("    └─ Last message by: %s%s | \"%s\"\n", authorName, botIndicator, messageText)</span>
                        }
                }
                <span class="cov0" title="0">fmt.Println()

                if isDryRun </span><span class="cov0" title="0">{
                        fmt.Printf("--- DRY RUN ---\n")
                        fmt.Printf("Would warn %d channels about upcoming archival\n", len(toWarn))
                        if len(toWarn) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("Example warning message for #%s:\n", toWarn[0].Name)
                                exampleMessage := client.FormatInactiveChannelWarning(toWarn[0], warnSeconds, archiveSeconds)
                                fmt.Printf("%s\n", exampleMessage)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("--- END DRY RUN ---\n\n")</span>
                } else<span class="cov0" title="0"> {
                        fmt.Printf("Sending warnings to %d channels (joining channels as needed)...\n", len(toWarn))
                        warningsSent := 0
                        for _, channel := range toWarn </span><span class="cov0" title="0">{
                                if err := client.WarnInactiveChannel(channel, warnSeconds, archiveSeconds); err != nil </span><span class="cov0" title="0">{
                                        logger.WithFields(logger.LogFields{
                                                "channel": channel.Name,
                                                "error":   err.Error(),
                                        }).Error("Failed to send warning")
                                        fmt.Printf("  Failed to warn #%s: %s\n", channel.Name, err.Error())
                                }</span> else<span class="cov0" title="0"> {
                                        warningsSent++
                                        logger.WithField("channel", channel.Name).Info("Warning sent successfully")
                                        fmt.Printf("  ✓ Warned #%s\n", channel.Name)
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("Warnings sent: %d/%d\n\n", warningsSent, len(toWarn))</span>
                }
        }

        // Process archival
        <span class="cov0" title="0">if len(toArchive) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Channels to archive (grace period expired):\n")
                for _, channel := range toArchive </span><span class="cov0" title="0">{
                        fmt.Printf("  #%s (inactive since: %s, members: %d)\n",
                                channel.Name,
                                channel.LastActivity.Format("2006-01-02 15:04:05"),
                                channel.MemberCount)

                        // Show last message details if available
                        if channel.LastMessage != nil </span><span class="cov0" title="0">{
                                messageText := channel.LastMessage.Text
                                if len(messageText) &gt; 60 </span><span class="cov0" title="0">{
                                        messageText = messageText[:57] + "..."
                                }</span>
                                <span class="cov0" title="0">messageText = strings.ReplaceAll(messageText, "\n", " ")

                                authorName := channel.LastMessage.UserName
                                if authorName == "" </span><span class="cov0" title="0">{
                                        authorName = channel.LastMessage.User
                                }</span>

                                <span class="cov0" title="0">botIndicator := ""
                                if channel.LastMessage.IsBot </span><span class="cov0" title="0">{
                                        botIndicator = " (bot)"
                                }</span>

                                <span class="cov0" title="0">fmt.Printf("    └─ Last message by: %s%s | \"%s\"\n", authorName, botIndicator, messageText)</span>
                        }
                }
                <span class="cov0" title="0">fmt.Println()

                if isDryRun </span><span class="cov0" title="0">{
                        fmt.Printf("--- DRY RUN ---\n")
                        fmt.Printf("Would archive %d channels\n", len(toArchive))
                        if len(toArchive) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("Example archival message for #%s:\n", toArchive[0].Name)
                                exampleArchivalMessage := client.FormatChannelArchivalMessage(toArchive[0], warnSeconds, archiveSeconds)
                                fmt.Printf("%s\n", exampleArchivalMessage)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("--- END DRY RUN ---\n\n")</span>
                } else<span class="cov0" title="0"> {
                        fmt.Printf("Archiving %d channels...\n", len(toArchive))
                        archived := 0
                        for _, channel := range toArchive </span><span class="cov0" title="0">{
                                if err := client.ArchiveChannelWithThresholds(channel, warnSeconds, archiveSeconds); err != nil </span><span class="cov0" title="0">{
                                        logger.WithFields(logger.LogFields{
                                                "channel": channel.Name,
                                                "error":   err.Error(),
                                        }).Error("Failed to archive channel")
                                        fmt.Printf("  Failed to archive #%s: %s\n", channel.Name, err.Error())
                                }</span> else<span class="cov0" title="0"> {
                                        archived++
                                        logger.WithField("channel", channel.Name).Info("Channel archived successfully")
                                        fmt.Printf("  ✓ Archived #%s\n", channel.Name)
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("Channels archived: %d/%d\n\n", archived, len(toArchive))</span>
                }
        }

        <span class="cov0" title="0">if len(toWarn) == 0 &amp;&amp; len(toArchive) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("No inactive channels found. All channels are active or already processed.\n")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"
        "time"

        "github.com/astrostl/slack-buddy-ai/pkg/logger"
        "github.com/astrostl/slack-buddy-ai/pkg/slack"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var healthCmd = &amp;cobra.Command{
        Use:   "health",
        Short: "Check health and connectivity",
        Long: `Check the health of your Slack connection, validate configuration, and test permissions.

This command verifies:
- Token validity and format
- Slack API connectivity  
- Required OAuth scopes and permissions (channels:read, channels:join, chat:write, channels:manage, users:read)
- Bot user information
- Basic API functionality`,
        SilenceUsage: true, // Don't show usage on errors
        RunE:         runHealth,
}

var (
        healthVerbose bool
)

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(healthCmd)
        healthCmd.Flags().BoolVarP(&amp;healthVerbose, "verbose", "v", false, "Show detailed health check information")
}</span>

func runHealth(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        fmt.Println("🔍 Running health checks...")
        fmt.Println()

        // Check 1: Configuration validation
        fmt.Print("✓ Configuration validation... ")
        token := viper.GetString("token")
        if token == "" </span><span class="cov8" title="1">{
                fmt.Println("❌ FAILED")
                fmt.Println("  Error: No Slack token configured")
                fmt.Println("  Fix: Set SLACK_TOKEN environment variable or use --token flag")
                return fmt.Errorf("configuration validation failed")
        }</span>
        <span class="cov8" title="1">fmt.Println("✅ PASSED")
        if healthVerbose </span><span class="cov8" title="1">{
                fmt.Printf("  Token format: %s...%s\n", token[:8], token[len(token)-8:])
        }</span>

        // Check 2: Token format validation
        <span class="cov8" title="1">fmt.Print("✓ Token format validation... ")
        if !isValidTokenFormat(token) </span><span class="cov8" title="1">{
                fmt.Println("❌ FAILED")
                fmt.Println("  Error: Invalid token format")
                fmt.Println("  Expected: Bot tokens must start with 'xoxb-'")
                return fmt.Errorf("token format validation failed")
        }</span>
        <span class="cov8" title="1">fmt.Println("✅ PASSED")

        // Check 3: Slack client creation
        fmt.Print("✓ Slack client initialization... ")
        client, err := slack.NewClient(token)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println("❌ FAILED")
                fmt.Printf("  Error: %v\n", err)
                return fmt.Errorf("client initialization failed: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("✅ PASSED")

        // Check 4: API connectivity
        fmt.Print("✓ Slack API connectivity... ")
        authInfo, err := client.TestAuth()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("❌ FAILED")
                fmt.Printf("  Error: %v\n", err)
                fmt.Println("  Fix: Verify your token is valid and has not been revoked")
                return fmt.Errorf("API connectivity failed: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("✅ PASSED")
        if healthVerbose </span><span class="cov0" title="0">{
                fmt.Printf("  Connected as: %s (team: %s)\n", authInfo.User, authInfo.Team)
                fmt.Printf("  User ID: %s, Team ID: %s\n", authInfo.UserID, authInfo.TeamID)
        }</span>

        // Check 5: OAuth scope validation
        <span class="cov0" title="0">fmt.Print("✓ OAuth scope validation (channels:read, channels:join, chat:write, channels:manage, users:read)... ")
        if healthVerbose </span><span class="cov0" title="0">{
                fmt.Printf("\n  Testing required scopes: channels:read, channels:join, chat:write, channels:manage, users:read\n")
                fmt.Printf("  Testing optional scopes: groups:read\n")
                fmt.Print("  Validation result: ")
        }</span>
        <span class="cov0" title="0">scopes, err := client.CheckOAuthScopes()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("❌ FAILED")
                fmt.Printf("  Error: %v\n", err)
                return fmt.Errorf("scope validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">requiredScopes := map[string]bool{
                "channels:read":   true, // Required - list channels
                "channels:join":   true, // Required - join channels for warnings
                "chat:write":      true, // Required - post warning messages
                "channels:manage": true, // Required - archive channels
                "users:read":      true, // Required - resolve user names for message authors
        }
        optionalScopes := map[string]bool{
                "groups:read": false, // Optional - access private channels
        }

        var missingRequired []string
        var missingOptional []string

        for scope := range requiredScopes </span><span class="cov0" title="0">{
                if !scopes[scope] </span><span class="cov0" title="0">{
                        missingRequired = append(missingRequired, scope)
                }</span>
        }

        <span class="cov0" title="0">for scope := range optionalScopes </span><span class="cov0" title="0">{
                if !scopes[scope] </span><span class="cov0" title="0">{
                        missingOptional = append(missingOptional, scope)
                }</span>
        }

        <span class="cov0" title="0">if len(missingRequired) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("❌ FAILED")
                fmt.Println("  Missing REQUIRED OAuth scopes:")
                for _, scope := range missingRequired </span><span class="cov0" title="0">{
                        fmt.Printf("    - %s\n", scope)
                }</span>
                <span class="cov0" title="0">if len(missingOptional) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("  Missing OPTIONAL OAuth scopes:")
                        for _, scope := range missingOptional </span><span class="cov0" title="0">{
                                fmt.Printf("    - %s (private channels won't be accessible)\n", scope)
                        }</span>
                }
                <span class="cov0" title="0">fmt.Println("  Fix: Add missing OAuth scopes in your Slack app settings at https://api.slack.com/apps")
                return fmt.Errorf("missing required OAuth scopes")</span>
        }

        <span class="cov0" title="0">fmt.Println("✅ PASSED")
        if healthVerbose </span><span class="cov0" title="0">{
                fmt.Println("  OAuth scope test results:")

                // Show required scopes first
                fmt.Println("    Required scopes:")
                for scope := range requiredScopes </span><span class="cov0" title="0">{
                        status := "❌"
                        if scopes[scope] </span><span class="cov0" title="0">{
                                status = "✅"
                        }</span>
                        <span class="cov0" title="0">var testMethod string
                        switch scope </span>{
                        case "channels:read":<span class="cov0" title="0">
                                testMethod = "tested with GetConversations()"</span>
                        case "channels:join":<span class="cov0" title="0">
                                testMethod = "tested with JoinConversation()"</span>
                        case "chat:write":<span class="cov0" title="0">
                                testMethod = "tested with PostMessage()"</span>
                        case "channels:manage":<span class="cov0" title="0">
                                testMethod = "tested with ArchiveConversation()"</span>
                        case "users:read":<span class="cov0" title="0">
                                testMethod = "tested with GetUsers()"</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("      %s %s - %s\n", status, scope, testMethod)</span>
                }

                // Show optional scopes
                <span class="cov0" title="0">fmt.Println("    Optional scopes:")
                for scope := range optionalScopes </span><span class="cov0" title="0">{
                        status := "❌"
                        if scopes[scope] </span><span class="cov0" title="0">{
                                status = "✅"
                        }</span>
                        <span class="cov0" title="0">var testMethod string
                        switch scope </span>{
                        case "groups:read":<span class="cov0" title="0">
                                testMethod = "tested with GetConversations(private_channel)"</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("      %s %s - %s\n", status, scope, testMethod)</span>
                }
        }

        <span class="cov0" title="0">if len(missingOptional) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("  ⚠️  Note: Some optional scopes are missing - private channels won't be accessible")
        }</span>

        // Check 6: Basic functionality test
        <span class="cov0" title="0">fmt.Print("✓ Basic functionality test... ")
        if err := testBasicFunctionality(client); err != nil </span><span class="cov0" title="0">{
                fmt.Println("⚠️  WARNING")
                fmt.Printf("  Warning: %v\n", err)
                fmt.Println("  Note: Basic connectivity works, but some features may be limited")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("✅ PASSED")
        }</span>

        <span class="cov0" title="0">fmt.Println()
        fmt.Println("🎉 Health check completed successfully!")
        fmt.Printf("   Connected as: %s (team: %s)\n", authInfo.User, authInfo.Team)
        fmt.Println("   All systems operational")

        return nil</span>
}

func isValidTokenFormat(token string) bool <span class="cov8" title="1">{
        return len(token) &gt; 8 &amp;&amp; (token[:5] == "xoxb-" || token[:5] == "xoxp-")
}</span>

func testBasicFunctionality(client *slack.Client) error <span class="cov8" title="1">{
        // Test getting channel list with a reasonable timeout
        logger.WithField("operation", "health_check").Debug("Testing basic channel listing functionality")

        cutoffTime := time.Now().Add(-24 * time.Hour)
        channels, err := client.GetNewChannels(cutoffTime)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("channel listing test failed: %w", err)
        }</span>

        <span class="cov8" title="1">if healthVerbose </span><span class="cov8" title="1">{
                fmt.Printf("  Successfully retrieved channel information (%d channels checked)\n", len(channels))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func contains(s, substr string) bool <span class="cov0" title="0">{
        return len(s) &gt;= len(substr) &amp;&amp;
                (len(substr) == 0 ||
                        (len(s) &gt; 0 &amp;&amp;
                                (s == substr ||
                                        (len(s) &gt; len(substr) &amp;&amp;
                                                (s[:len(substr)] == substr ||
                                                        s[len(s)-len(substr):] == substr ||
                                                        containsSubstring(s, substr))))))
}</span>

func containsSubstring(s, substr string) bool <span class="cov8" title="1">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov8" title="1">{
                if s[i:i+len(substr)] == substr </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/astrostl/slack-buddy-ai/pkg/logger"

        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

// Version information passed from main.
var (
        version   string
        buildTime string
        gitCommit string
)

var rootCmd = &amp;cobra.Command{
        Use:   "slack-buddy",
        Short: "A CLI tool to help manage Slack workspaces",
        Long:  `Slack Buddy is a CLI tool that helps make Slack workspaces more useful and tidy.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Handle --version flag when no subcommand is specified
                if versionFlag, _ := cmd.Flags().GetBool("version"); versionFlag </span><span class="cov0" title="0">{
                        fmt.Printf("slack-buddy version %s\n", version)
                        if buildTime != "unknown" </span><span class="cov0" title="0">{
                                fmt.Printf("Built: %s\n", buildTime)
                        }</span>
                        <span class="cov0" title="0">if gitCommit != "unknown" </span><span class="cov0" title="0">{
                                fmt.Printf("Commit: %s\n", gitCommit)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                // Show help if no version flag and no subcommand
                <span class="cov0" title="0">_ = cmd.Help()</span>
        },
        CompletionOptions: cobra.CompletionOptions{
                DisableDefaultCmd: true,
        },
}

func Execute(ver, build, commit string) <span class="cov0" title="0">{
        // Store version information for use in commands
        version = ver
        buildTime = build
        gitCommit = commit

        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // Cobra already displays the error, no need to log it again
                os.Exit(1)
        }</span>
}

func init() <span class="cov8" title="1">{
        cobra.OnInitialize(initConfig)

        // Global flags
        rootCmd.PersistentFlags().String("token", "", "Slack bot token (can also be set via SLACK_TOKEN env var)")
        rootCmd.PersistentFlags().BoolP("debug", "d", false, "Enable debug logging")
        rootCmd.Flags().BoolP("version", "v", false, "Print version information")

        // Bind flags to viper
        if err := viper.BindPFlag("token", rootCmd.PersistentFlags().Lookup("token")); err != nil </span><span class="cov0" title="0">{
                logger.WithField("error", err.Error()).Fatal("Failed to bind token flag")
        }</span>
        <span class="cov8" title="1">if err := viper.BindPFlag("debug", rootCmd.PersistentFlags().Lookup("debug")); err != nil </span><span class="cov0" title="0">{
                logger.WithField("error", err.Error()).Fatal("Failed to bind debug flag")
        }</span>

}

func initConfig() <span class="cov8" title="1">{
        viper.SetEnvPrefix("SLACK")
        viper.AutomaticEnv()

        // Explicitly bind environment variables
        _ = viper.BindEnv("token", "SLACK_TOKEN")
        _ = viper.BindEnv("debug", "SLACK_DEBUG")

        // Set log level based on debug flag
        if viper.GetBool("debug") </span><span class="cov0" title="0">{
                logger.Log.SetLevel(logrus.DebugLevel)
        }</span> else<span class="cov8" title="1"> {
                logger.Log.SetLevel(logrus.InfoLevel)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Print version information",
        Long:  `Display version information including build time and git commit.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Printf("slack-buddy version %s\n", version)
                if buildTime != "unknown" </span><span class="cov0" title="0">{
                        fmt.Printf("Built: %s\n", buildTime)
                }</span>
                <span class="cov0" title="0">if gitCommit != "unknown" </span><span class="cov0" title="0">{
                        fmt.Printf("Commit: %s\n", gitCommit)
                }</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(versionCmd)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
